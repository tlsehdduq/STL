파일 정보 : 소스.cpp, 크기:1833
 저장 시간 : 2022-03-02 14:47:29 GMT+9

//-----------------------------------------------------------------------------
//2022.3.2 수 34                    월23수34                          (1주 1일)
// 
// - 강의소개 (책,사이트(cppreference.com)
// - 코딩 스타일(c++ coding convention - 참고(구글에서 google c++ coding convention)
// - 컴파일러 환경 셋팅 - Release, x64
//						- 메뉴 - 프로젝트 - 속성 - 최신 초안기능
// - save 파일작성	(한학기 강의 내용을 자동저장한다)
// 
// 공부할 내용 - 파일입출력(텍스트/바이너리모드) 
//-----------------------------------------------------------------------------

#include<iostream>
#include<string_view>
#include<fstream>
#include<filesystem>
#include<vector>
#include<iterator>
#include<chrono>
#include<algorithm>
using namespace std;


//코딩할 내용 - "소스.cpp"를 읽어 강의저장파일에 덧붙인다.

void save(string_view);

int main()
{	
	cout << "string 크기 - " << sizeof(string) << endl;
	cout << "string_view 크기 - " << sizeof(string_view) << endl;

	save("소스.cpp");
}

void save(string_view fname)
{
	//현재 시간을 화면에 출력한다.
	auto time = floor<chrono::seconds>(chrono::system_clock::now());
	cout << chrono::zoned_time("Asia/Seoul", time) << endl;

	//읽을 파일을 연다
	ifstream in{ fname.data() };
	
	//저장할 파일도 연다(덧붙이기 모드로 열어야 한다)
	ofstream out{ "2022 1학기 STL 월23수34 강의저장.txt",ios::app };

	// 저장할 파일의 크기와 현재 시간을 강의저장 파일에 기록한다
	out << "파일 정보 : " <<fname<<", 크기:" << filesystem::file_size(fname) << endl;
	out <<" 저장 시간 : " << chrono::zoned_time("Asia/Seoul", time) << endl;
	out << endl;

	// 벡터를 만들면서 in 파일의 내용을 다 읽어온다
	vector<char> v{ istreambuf_iterator<char>{in}, {} };
	

	// v로 읽어 온 파일을 out에 출력한다.
	copy(v.begin(), v.end(), ostream_iterator<char>{out});
}파일 정보 : 소스.cpp, 크기:573
 저장 시간 : 2022-03-07 10:57:39 GMT+9

//-----------------------------------------------------------------------------
//2022.3.2 수 34                    월23수34                          (1주 1일)
//
// save 함수를 분리한다.
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;

//코딩할 내용 - "소스.cpp"를 읽어 강의저장파일에 덧붙인다.

int main()
{	/*
	cout << "string 크기 - " << sizeof(string) << endl;
	cout << "string_view 크기 - " << sizeof(string_view) << endl;*/

	save("소스.cpp");
}
파일 정보 : save.h, 크기:75
2022-03-07 10:59:48 GMT+9
 저장 시간 : 2022-03-07 10:59:48 GMT+9

#pragma once
#include<string_view>

void save(std::string_view fname);
파일 정보 : save.cpp, 크기:1280
2022-03-07 10:59:48 GMT+9
 저장 시간 : 2022-03-07 10:59:48 GMT+9

//-----------------------------------------------------------------------------
//SAVE.CPP
//
// 저장할 파일을 알려주면 한학기 강의를 저장할 파일에 덧붙인다.
//        "2022 1학기 STL 월23수34 강의저장.txt"
//	
// 2022. 3 . 7		

#include "save.h"
#include<fstream>
#include<filesystem>
#include<chrono>
#include<vector>
#include<algorithm>

void save(std::string_view fname)
{
	//읽을 파일을 연다
	std::ifstream in{ fname.data() };

	//저장할 파일도 연다(덧붙이기 모드로 열어야 한다)
	std::ofstream out{ "2022 1학기 STL 월23수34 강의저장.txt",std::ios::app };

	// 저장할 파일의 이름과 크기를 기록한다(c++17)
	out << "파일 정보 : " << fname << ", 크기:" << std::filesystem::file_size(fname) << std::endl;//17

	//현재 시간을 화면에 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;


	out << " 저장 시간 : " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;//20
	out << std::endl;

	// 벡터를 만들면서 in 파일의 내용을 다 읽어온다 (STL 컨테이너)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };


	// v로 읽어 온 파일을 out에 출력한다.(STL 알고리즘)
	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});
}파일 정보 : 소스.cpp, 크기:484
2022-03-07 10:59:48 GMT+9
 저장 시간 : 2022-03-07 10:59:48 GMT+9

//-----------------------------------------------------------------------------
//2022.3.2 수 34                    월23수34                          (1주 1일)
//
// save 함수를 분리한다.
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;

//코딩할 내용 - "소스.cpp"를 읽어 강의저장파일에 덧붙인다.

int main(){
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}
파일 정보 : save.h, 크기:75
2022-03-07 11:01:02 GMT+9
 저장 시간 : 2022-03-07 11:01:02 GMT+9

#pragma once
#include<string_view>

void save(std::string_view fname);
파일 정보 : save.cpp, 크기:1280
2022-03-07 11:01:02 GMT+9
 저장 시간 : 2022-03-07 11:01:02 GMT+9

//-----------------------------------------------------------------------------
//SAVE.CPP
//
// 저장할 파일을 알려주면 한학기 강의를 저장할 파일에 덧붙인다.
//        "2022 1학기 STL 월23수34 강의저장.txt"
//	
// 2022. 3 . 7		

#include "save.h"
#include<fstream>
#include<filesystem>
#include<chrono>
#include<vector>
#include<algorithm>

void save(std::string_view fname)
{
	//읽을 파일을 연다
	std::ifstream in{ fname.data() };

	//저장할 파일도 연다(덧붙이기 모드로 열어야 한다)
	std::ofstream out{ "2022 1학기 STL 월23수34 강의저장.txt",std::ios::app };

	// 저장할 파일의 이름과 크기를 기록한다(c++17)
	out << "파일 정보 : " << fname << ", 크기:" << std::filesystem::file_size(fname) << std::endl;//17

	//현재 시간을 화면에 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;


	out << " 저장 시간 : " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;//20
	out << std::endl;

	// 벡터를 만들면서 in 파일의 내용을 다 읽어온다 (STL 컨테이너)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };


	// v로 읽어 온 파일을 out에 출력한다.(STL 알고리즘)
	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});
}파일 정보 : 소스.cpp, 크기:489
2022-03-07 11:01:02 GMT+9
 저장 시간 : 2022-03-07 11:01:02 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
//코딩할 내용 - "소스.cpp"를 읽어 강의저장파일에 덧붙인다.
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;


//----------
int main(){
//----------

	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:424
2022-03-07 11:01:41 GMT+9
 저장 시간 : 2022-03-07 11:01:41 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
//할 일 - save 함수를 분리한다.
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;


//----------
int main(){
//----------

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:650
2022-03-07 11:05:23 GMT+9
 저장 시간 : 2022-03-07 11:05:23 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.

void change(int i_a, int i_b)
{
	int cmp = 0;
	cmp = i_a;
	i_a = i_b;
	i_b = cmp;
}

//----------
int main(){
//----------
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:650
2022-03-07 11:06:04 GMT+9
 저장 시간 : 2022-03-07 11:06:04 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.

void change(int i_a, int i_b)
{
	int cmp = 0;
	cmp = i_a;
	i_a = i_b;
	i_b = cmp;
}

//----------
int main(){
//----------
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:653
2022-03-07 11:06:22 GMT+9
 저장 시간 : 2022-03-07 11:06:22 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.

void change(int i_a, int i_b)
{
	int cmp{ 0 };
	cmp = i_a;
	i_a = i_b;
	i_b = cmp;

}

//----------
int main(){
//----------
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:685
2022-03-07 11:13:26 GMT+9
 저장 시간 : 2022-03-07 11:13:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.

void change(int a, int b)
{
	int temp = 0;
	int i_a = a;
	int i_b = b;

	temp = i_a;
	i_a = i_b;
	i_b = temp;

}

//----------
int main(){
//----------
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:664
2022-03-07 11:15:01 GMT+9
 저장 시간 : 2022-03-07 11:15:01 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.

void change(int &a, int &b);

//----------
int main(){
//----------
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;

}파일 정보 : 소스.cpp, 크기:794
2022-03-07 11:25:25 GMT+9
 저장 시간 : 2022-03-07 11:25:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;
using Dog = int;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.

void change(int &a, int &b);

//class changeint
//{
//public:
//	int a{};
//	int b{};
//	int c{};
//
//}Dog;
//changeint Dog;

//----------
int main(){
//----------
	Dog a{ 1 };
	Dog b{ 2 };

	
	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}
파일 정보 : 소스.cpp, 크기:1087
2022-03-07 11:50:39 GMT+9
 저장 시간 : 2022-03-07 11:50:39 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.
// class Dog를 작성할 것


class Dog {
	int num;
public:
	Dog(int n) : num{ n } {
	}

	friend ostream& operator<<(ostream&, const Dog&);

}; 
ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.num;
	return os;
}

void change(int &a, int &b);
void change(Dog&, Dog&);


//----------
int main(){
//----------
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b)
{
	Dog temp{ a }; // 이미있는 객체를 이용해서 만들기 때문에 복사가된다./
	a = b; // a.operator = (b);
	b = temp;

}
파일 정보 : 소스.cpp, 크기:1306
2022-03-07 12:06:22 GMT+9
 저장 시간 : 2022-03-07 12:06:22 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//  
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

//[문제] main의 코드를 변경하면 안된다.
// a와 b의 값이 바뀌어야 한다.
// class Dog를 작성할 것

//생성자는 메모리를 만드는데 관여하지 않는다. 
//스택에 메모리를 생성하는것은 컴파일러가 하는일,
//기록하는일을 하는것이 생성자의 일
// 
//

class Dog {
	int num;
public:
	Dog(int n) : num{ n } {
	}

	friend ostream& operator << (ostream&, const Dog&);

	/*operator int() {
		return *this;

	}*/

}; 
ostream& operator << (ostream& os, const Dog& dog)
{
	os << dog.num;
	return os;
}

void change(int &a, int &b);
void change(Dog&, Dog&);


//----------
int main(){
//----------
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << "," << b << endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;// 
	b = temp;
}

void change(Dog& a, Dog& b)
{
	Dog temp{ a }; // 이미있는 객체를 이용해서 만들기 때문에 복사가된다./
	a = b; // a.operator = (b);
	b = temp;

}
파일 정보 : 소스.cpp, 크기:783
2022-03-07 12:21:33 GMT+9
 저장 시간 : 2022-03-07 12:21:33 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"

using namespace std;
//[문제] 다음 main을 수정없이 실행시키는 템플릿 함수를 작성하라.
// 
//----------
template <class T>
void change(T& a, T& b)
{
	T tem{ a };
	a = b;
	b = tem;
}
class Dog {
public:
	Dog(string,int){}
};

int main(){
//----------
	int a{ 1 }, b{ 2 };
	change(a, b);

	string c = "STL"s;
	string d = "C++"s;
	change(c,d);

	Dog e{ "코코",3 };
	Dog f{ "댕댕이",2 };
	change(e, f);


	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:783
2022-03-19 23:24:32 GMT+9
 저장 시간 : 2022-03-19 23:24:32 GMT+9

//-----------------------------------------------------------------------------
//2022.3.7 월 234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"

using namespace std;
//[문제] 다음 main을 수정없이 실행시키는 템플릿 함수를 작성하라.
// 
//----------
template <class T>
void change(T& a, T& b)
{
	T tem{ a };
	a = b;
	b = tem;
}
class Dog {
public:
	Dog(string,int){}
};

int main(){
//----------
	int a{ 1 }, b{ 2 };
	change(a, b);

	string c = "STL"s;
	string d = "C++"s;
	change(c,d);

	Dog e{ "코코",3 };
	Dog f{ "댕댕이",2 };
	change(e, f);


	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:683
2022-03-19 23:30:01 GMT+9
 저장 시간 : 2022-03-19 23:30:01 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>
using namespace std;
//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.


int main(){
	default_random_engine dre;
	uniform_int_distribution<> uid;

	int num[1000]{};
	for (int i = 0; i < size(num); i++)
	{
		num[i] = uid(dre);
	}
	for (int n : num)
	{
		cout << n << " ";
	}

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:699
2022-03-19 23:36:29 GMT+9
 저장 시간 : 2022-03-19 23:36:29 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.


int main(){

	default_random_engine dre;
	uniform_int_distribution<> uid{ 0,1000 };

	int num[1000]{};
	for (int i = 0; i < size(num); i++)
	{
		num[i] = uid(dre);
	}
	for (int n : num)
	{
		cout << n << " ";
	}

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:542
2022-03-19 23:47:30 GMT+9
 저장 시간 : 2022-03-19 23:47:30 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

int main(){
	int num = 0x7FFFFFFFF;
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:558
2022-03-19 23:47:39 GMT+9
 저장 시간 : 2022-03-19 23:47:39 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

int main(){
	int num = 0x7FFFFFFFF;
	cout << num; 
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:557
2022-03-19 23:47:47 GMT+9
 저장 시간 : 2022-03-19 23:47:47 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

int main(){
	int num = 0x7FFFFFFF;  //최대값 ,.
	cout << num; 
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:566
2022-03-19 23:47:58 GMT+9
 저장 시간 : 2022-03-19 23:47:58 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

int main(){
	unsigned int num = 0x7FFFFFFF;
	cout << num; 
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:554
2022-03-19 23:48:36 GMT+9
 저장 시간 : 2022-03-19 23:48:36 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
#include<random>

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

int main(){
	int num = INT_MAX;
	cout << num; 
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:591
2022-03-19 23:50:39 GMT+9
 저장 시간 : 2022-03-19 23:50:39 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

int main(){
	
	int num = numeric_limits<int>::max();
	cout << "int 의 최댓값 - " << num << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:601
2022-03-20 00:02:21 GMT+9
 저장 시간 : 2022-03-20 00:02:21 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.
default_random_engine dre;

int main(){
	
	cout << "엔진 크기 - " << sizeof(dre) << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:620
2022-03-20 00:05:55 GMT+9
 저장 시간 : 2022-03-20 00:05:55 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.
default_random_engine dre;

int main(){
	
	uniform_int_distribution uid;

	cout << uid(dre);
	cout << endl;
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:653
2022-03-20 00:07:51 GMT+9
 저장 시간 : 2022-03-20 00:07:51 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

random_device rd;
default_random_engine dre{  rd()  };


int main(){
	
	uniform_int_distribution uid;

	cout << uid(dre);
	cout << endl;
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:672
2022-03-20 00:08:41 GMT+9
 저장 시간 : 2022-03-20 00:08:41 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
//
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

random_device rd;
default_random_engine dre{  rd()  };


int main(){
	
	uniform_int_distribution uid;
	for (int i = 0; i < 1000; i++)
	{
		cout << uid(dre);
	}
		cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:679
2022-03-20 00:09:04 GMT+9
 저장 시간 : 2022-03-20 00:09:04 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
//
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

random_device rd;
default_random_engine dre{  rd()  };

int main(){
	
	uniform_int_distribution uid;
	for (int i = 0; i < 1000; i++)
	{
		cout << uid(dre) << '\t';
	}
	cout << endl;

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:679
2022-03-20 00:09:43 GMT+9
 저장 시간 : 2022-03-20 00:09:43 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
//
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를 화면에 출력하라.
//[문제] int의 최대값을 출력하라.

random_device rd;
default_random_engine dre{  rd()  };


int main(){
	
	uniform_int_distribution uid;
	for (int i = 0; i < 1000; i++)
	{
		cout << uid(dre) << '\t';
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:708
2022-03-20 00:13:35 GMT+9
 저장 시간 : 2022-03-20 00:13:35 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
//
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>
#include<fstream>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//
random_device rd;
default_random_engine dre{  rd()  };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };
	for (int i = 0; i < 1000; i++)
	{
		out << uid(dre);
	}
	out << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:716
2022-03-20 00:14:10 GMT+9
 저장 시간 : 2022-03-20 00:14:10 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
//
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>
#include<fstream>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//
random_device rd;
default_random_engine dre{  rd()  };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };
	for (int i = 0; i < 1000; i++)
	{
		out << uid(dre) << "  ";
	}
	out << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:718
2022-03-20 00:16:38 GMT+9
 저장 시간 : 2022-03-20 00:16:38 GMT+9

//-----------------------------------------------------------------------------
//2022.3.10  234                    월23수34                          (1주 1일)
//
//
// 
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>
#include<fstream>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//
random_device rd;
default_random_engine dre{  rd()  };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		out << uid(dre) << '\t';
	}
	out << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:843
2022-03-20 12:46:56 GMT+9
 저장 시간 : 2022-03-20 12:46:56 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		--다음시간 - 파일저장 다시보기
//		--숙제 - 파일입출력 알아보기
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>
#include<fstream>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		out << uid(dre) << '\t';
	}
	out << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:787
2022-03-20 12:47:26 GMT+9
 저장 시간 : 2022-03-20 12:47:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"
#include<random>
#include<fstream>


using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		cout << uid(dre) << '\t';
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:801
2022-03-20 12:49:56 GMT+9
 저장 시간 : 2022-03-20 12:49:56 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		//format();
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:816
2022-03-20 12:52:00 GMT+9
 저장 시간 : 2022-03-20 12:52:00 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		format("{:80}", uid(dre));
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:824
2022-03-20 12:52:27 GMT+9
 저장 시간 : 2022-03-20 12:52:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		cout << format("{:80}", uid(dre));
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:825
2022-03-20 12:53:22 GMT+9
 저장 시간 : 2022-03-20 12:53:22 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		cout << format("{:^80}", uid(dre));
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:824
2022-03-20 12:53:46 GMT+9
 저장 시간 : 2022-03-20 12:53:46 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		cout << format("{:20}", uid(dre));
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:861
2022-03-20 12:54:43 GMT+9
 저장 시간 : 2022-03-20 12:54:43 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		cout << format("{:19}", uid(dre));
		if (i % 4 == 0)
			cout << endl;
	}
	cout << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:859
2022-03-20 12:55:16 GMT+9
 저장 시간 : 2022-03-20 12:55:16 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		cout << format("{:19}", uid(dre));
		if (i % 4 == 0)
			out << endl;
	}
	out << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:858
2022-03-20 12:55:55 GMT+9
 저장 시간 : 2022-03-20 12:55:55 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		out << format("{:19}", uid(dre));
		if (i % 4 == 0)
			out << endl;
	}
	out << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:862
2022-03-20 12:56:41 GMT+9
 저장 시간 : 2022-03-20 12:56:41 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
//		대량의 자료를 생성 저장 조작
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<random>
#include<fstream>
#include<format>			//c++20

#include "save.h"

using namespace std;

//[문제] 임의의 값을 갖는(랜덤값을 갖는)  int 1000개를
// "int 천개.txt" 파일에 저장하라.
//

default_random_engine dre{    };


int main(){
	
	uniform_int_distribution uid;
	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; i++)
	{
		out << format("{:19}", uid(dre));
		if ((i+3) % 4 == 0)
			out << endl;
	}
	out << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:597
2022-03-20 13:00:36 GMT+9
 저장 시간 : 2022-03-20 13:00:36 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.

int main(){
	
	ifstream in{ "int 천개.txt" };
	
	if (!in)
	{
		cout << "파일 열기 실패";
		return 0;
	}

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:617
2022-03-20 13:02:13 GMT+9
 저장 시간 : 2022-03-20 13:02:13 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.

int main(){
	
	ifstream in{ "int 천개.txt" };
	
	int num;

	while (!in.eof())
	{
		in >> num;
		cout << num << '\t';
	}
		
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:595
2022-03-20 13:02:53 GMT+9
 저장 시간 : 2022-03-20 13:02:53 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.

int main(){
	
	ifstream in{ "int 천개.txt" };
	
	int num;

	while (in >> num)
		cout << num << '\t';
		
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:625
2022-03-20 13:03:46 GMT+9
 저장 시간 : 2022-03-20 13:03:46 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.

int main(){
	
	ifstream in{ "int 천개.txt" };
	int num{};
	for (int i{}; i < 1000; ++i)
	{
		in >> num;
		cout << num << "\t";
	}
		
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:744
2022-03-20 13:09:57 GMT+9
 저장 시간 : 2022-03-20 13:09:57 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라.
int main(){
	
	ifstream in{ "int 천개.txt" };
	int num[1000]{};
	for (int i{}; i < 1000; ++i)
	{
		in >> num[i];
		if (num[i] > num[i + 1])
		{
			num[i + 1] = num[i];
		}
		
	}
		cout << num[1000] << "\t";
		
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:741
2022-03-20 13:12:19 GMT+9
 저장 시간 : 2022-03-20 13:12:19 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라.
int main(){
	
	ifstream in{ "int 천개.txt" };
	int num{};
	int max{ numeric_limits<int>::min() };
	for (int i{}; i < 1000; ++i)
	{
		in >> num;
		if (max < num)
		{
			max = num;
		}
	}
	cout << max << endl;
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:830
2022-03-20 13:16:17 GMT+9
 저장 시간 : 2022-03-20 13:16:17 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라.
// 코드를 답안지에 쓰고, 출력되는 큰 값도 답지에 적어라
int main(){
	
	ifstream in{ "int 천개.txt" };
	//여기 들어갈 코드를 답지에 적어라.

	int num{};
	int max{ numeric_limits<int>::min() };
	for (int i{}; i < 1000; ++i)
	{
		in >> num;
		if (max < num)		
			max = num;
	}
	cout << max << endl;
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:728
2022-03-20 13:20:59 GMT+9
 저장 시간 : 2022-03-20 13:20:59 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라.
// 코드를 답안지에 쓰고, 출력되는 큰 값도 답지에 적어라
int main(){
	
	ifstream in{ "int 천개.txt" };

	cout << "최대값 - " << *max_element(istream_iterator<int>{in},{} ) << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:728
2022-03-20 13:22:00 GMT+9
 저장 시간 : 2022-03-20 13:22:00 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

// [문제] "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라.
// 코드를 답안지에 쓰고, 출력되는 큰 값도 답지에 적어라
int main(){
	
	ifstream in{ "int 천개.txt" };

	cout << "최대값 - " << *max_element(istream_iterator<int>{in},{} ) << endl;

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:660
2022-03-20 13:29:17 GMT+9
 저장 시간 : 2022-03-20 13:29:17 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// [문제] int 1000개를 저장하는데 필요한 메모리는 몇 바이트 입니까?
// - 만든 사람 마음대로
// 그렇지만 자료를 입출력 하는데 가장 빠른 방법은 저수준 I/O를 사용하는 것이다.

int main(){
	
	ifstream in{ "int 천개.txt" };
	cout << sizeof(in);
	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:838
2022-03-20 13:32:45 GMT+9
 저장 시간 : 2022-03-20 13:32:45 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include<random>
#include "save.h"

using namespace std;

// [문제] int 1000개를 저장하는데 필요한 메모리는 몇 바이트 입니까?
// - 만든 사람 마음대로
// 그렇지만 자료를 입출력 하는데 가장 빠른 방법은 저수준 I/O를 사용하는 것이다.

int main(){
	default_random_engine dre;
	uniform_int_distribution uid;

	ofstream out{ "int 천개.txt" };
	
	int num;

	for (int i{}; i < 1000; i++)
	{
		num = uid(dre);
		out.write((const char*)&num,sizeof(int));
	}

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:777
2022-03-20 13:34:39 GMT+9
 저장 시간 : 2022-03-20 13:34:39 GMT+9

//-----------------------------------------------------------------------------
//2022.3.16  234                    월23수34                          (3주 2일)
//
//		파일에 있는 자료 읽어오기.
//		
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include<fstream>
#include<random>
#include "save.h"

using namespace std;

// [문제] 출력파일의 wirte함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 설명하라.

default_random_engine dre;
uniform_int_distribution uid;

int main(){

	ofstream out{ "int 천개.txt" };
	
	int num;

	for (int i{}; i < 1000; i++)
	{
		num = uid(dre);
		out.write((const char*)&num,sizeof(int));
	}

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:573
2022-03-21 10:32:33 GMT+9
 저장 시간 : 2022-03-21 10:32:33 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		
//-----------------------------------------------------------------------------
//
#include<iostream>
#include "save.h"

using namespace std;
//[문제] 사용자가 원하는 갯수만큼 int를 저장할 메모리를 만들어라
//그 메ㅗㅁ리를 1부터 증가하는 int값으로 채워라
//다 더한 값을 출력하라.

int main(){

	

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:615
2022-03-21 10:34:33 GMT+9
 저장 시간 : 2022-03-21 10:34:33 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main(){

	int num;
	cout << "몇 개의 int를 원하십니까?";
	cin >> num;

	new int[num];

	save("소스.cpp");
}


파일 정보 : 소스.cpp, 크기:900
2022-03-21 10:44:22 GMT+9
 저장 시간 : 2022-03-21 10:44:22 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main(){
	int num;

	cout << "몇 개의 int를 원하십니까?";
	cin >> num;

	new int[num];

	int* p = new int[num];

	for (int i = 0; i < num; ++i)
		p[i] = i + 1;

	int sum{};

	for (int i = 0; i < num; ++i)
		sum += p[i];
	
	cout << " 1부터" << num << " 까지의 합은 " << sum << endl;

	save("소스.cpp");
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  
//   
//


파일 정보 : 소스.cpp, 크기:900
2022-03-21 10:44:34 GMT+9
 저장 시간 : 2022-03-21 10:44:34 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main(){
	int num;

	cout << "몇 개의 int를 원하십니까?";
	cin >> num;

	new int[num];

	int* p = new int[num];

	for (int i = 0; i < num; ++i)
		p[i] = i + 1;

	int sum{};

	for (int i = 0; i < num; ++i)
		sum += p[i];
	
	cout << " 1부터" << num << " 까지의 합은 " << sum << endl;

	save("소스.cpp");
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  
//   
//


파일 정보 : 소스.cpp, 크기:1275
2022-03-21 11:03:29 GMT+9
 저장 시간 : 2022-03-21 11:03:29 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

//[문제] 사용자가 원하는 갯수만큼 int 를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 다 더한 값을 출력하라. 
// - 이 과정을 영원히 반복하고 문제없게 고쳐라(10분)


using namespace std;

int main() {

	save("소스.cpp");

	while (true)
	{

		int num;

		cout << "몇 개의 int를 원하십니까?";
		cin >> num;

		new int[num];

		int* p = new int[num]; //이 메모리를 내가 관리하는 것이 아닌게 문제,
		

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		long sum{};

		for (int i = 0; i < num; ++i)
			sum += p[i]; //제대로된 합계를 구하지 못함.., 값이 커질경우 --- 즉 합계를 담을 수있는 메모리 한도를 벗어남.

		cout << " 1부터" << num << " 까지의 합은 " << sum << endl;
	}
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  


파일 정보 : 소스.cpp, 크기:1319
2022-03-21 11:05:56 GMT+9
 저장 시간 : 2022-03-21 11:05:56 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

//[문제] 사용자가 원하는 갯수만큼 int 를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 다 더한 값을 출력하라. 
// - 이 과정을 영원히 반복하고 문제없게 고쳐라(10분)


using namespace std;

int main() {

	save("소스.cpp");

	cout << sizeof(long long) << endl;

	while (true)
	{

		int num;

		cout << "몇 개의 int를 원하십니까?";
		cin >> num;

		new int[num];

		int* p = new int[num]; //이 메모리를 내가 관리하는 것이 아닌게 문제,
		

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		long long sum{};

		for (int i = 0; i < num; ++i)
			sum += p[i]; //제대로된 합계를 구하지 못함.., 값이 커질경우 --- 즉 합계를 담을 수있는 메모리 한도를 벗어남.

		cout << " 1부터" << num << " 까지의 합은 " << sum << endl;
	}
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  


파일 정보 : 소스.cpp, 크기:1337
2022-03-21 11:08:36 GMT+9
 저장 시간 : 2022-03-21 11:08:36 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

//[문제] 사용자가 원하는 갯수만큼 int 를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 다 더한 값을 출력하라. 
// - 이 과정을 영원히 반복하고 문제없게 고쳐라(10분)


using namespace std;

int main() {

	save("소스.cpp");

	cout << sizeof(long long) << endl;

	while (true)
	{

		long long num;

		cout << "몇 개의 int를 원하십니까?";
		cin >> num;

		new int[num];

		int* p = new int[num]; //이 메모리를 내가 관리하는 것이 아닌게 문제,
		

		for (long long i = 0; i < num; ++i)
			p[i] = i + 1;

		long long sum{};

		for (long long i = 0; i < num; ++i)
			sum += p[i]; //제대로된 합계를 구하지 못함.., 값이 커질경우 --- 즉 합계를 담을 수있는 메모리 한도를 벗어남.

		cout << " 1부터" << num << " 까지의 합은 " << sum << endl;
	}
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  



//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  


파일 정보 : 소스.cpp, 크기:1365
2022-03-21 11:19:48 GMT+9
 저장 시간 : 2022-03-21 11:19:48 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

//[문제] 사용자가 원하는 갯수만큼 int 를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 다 더한 값을 출력하라. 
// - 이 과정을 영원히 반복하고 문제없게 고쳐라(10분)


using namespace std;

int main() {

	save("소스.cpp");

	while (true)
	{

		int num;

		cout << "몇 개의 int를 원하십니까?";
		cin >> num;

		new int[num];
		int* p{};

		try {
			p = new int[num]; //이 메모리를 내가 관리하는 것이 아닌게 문제,
		}
		catch (exception& e) {
			cout << e.what() << endl;
		}

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		long long sum{};

		for (int i = 0; i < num; ++i)
			sum += p[i]; //제대로된 합계를 구하지 못함.., 값이 커질경우 --- 즉 합계를 담을 수있는 메모리 한도를 벗어남.

		cout << " 1부터" << num << " 까지의 합은 " << sum << endl;
	}
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  
// 
//
파일 정보 : 소스.cpp, 크기:1286
2022-03-21 11:40:44 GMT+9
 저장 시간 : 2022-03-21 11:40:44 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10] 대신 array<int,100>을 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

//[문제] 사용자가 원하는 갯수만큼 int 를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 1부터 num 까지 더할때 int의 최댓값을 넘지 않는 Num 값은?

using namespace std;

int main() {

	save("소스.cpp");

	int max = numeric_limits<int>::max();

	while (true)
	{

		int num;

		cout << "몇 개의 int를 원하십니까?";
		cin >> num;

		new int[num];


		int* p = new int[num];


		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		int sum{}; 

		for (int i = 0; i < num; ++i)
			sum += p[i]; //제대로된 합계를 구하지 못함.., 값이 커질경우 --- 즉 합계를 담을 수있는 메모리 한도를 벗어남.

		cout << " 1부터" << num << " 까지의 합은 " << sum << endl;

		delete[] p; // 메모리 반환.
	}
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  
// 
//
파일 정보 : 소스.cpp, 크기:1361
2022-03-21 11:43:43 GMT+9
 저장 시간 : 2022-03-21 11:43:43 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

//[문제] 사용자가 원하는 갯수만큼 int 를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 1부터 num 까지 더할때 int의 최댓값을 넘지 않는 Num 값은?

using namespace std;

int main() {

	save("소스.cpp");

	int max = numeric_limits<int>::max();

	while (true)
	{

		int num;

		cout << "몇 개의 int를 원하십니까?";
		cin >> num;

		new int[num];


		int* p = new int[num];


		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		int sum{}; 

		for (int i = 0; i < num; ++i)
			sum += p[i]; //제대로된 합계를 구하지 못함.., 값이 커질경우 --- 즉 합계를 담을 수있는 메모리 한도를 벗어남.

		cout << " 1부터" << num << " 까지의 합은 " << sum << endl;

		delete[] p; // 메모리 반환.
	}
}

//Memory
// 1. STACK  지역
// 2.DATA	전역
// 3. FREE STORE  
/

파일 정보 : 소스.cpp, 크기:808
2022-03-21 11:50:25 GMT+9
 저장 시간 : 2022-03-21 11:50:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

int main() {
	
	ifstream in{ "소스.cpp" }; // RAII -- > Resource acquisition is initialization 클래스 객체에서 자원을 관리.

	save("소스.cpp");
	
	in.close();//할 필요가 없다. 이미 초기화에서 관리를 해주기 때문에
}

파일 정보 : 소스.cpp, 크기:797
2022-03-21 11:53:26 GMT+9
 저장 시간 : 2022-03-21 11:53:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// 자원 관리 
struct Dog
{
	Dog() { cout << " Dog 생성" << endl; }
	~Dog() { cout << " Dog 소멸" << endl; }
};

int main() {

	Dog* dogs = new Dog[3];

	//
	save("소스.cpp");

	delete[] dogs;

}

파일 정보 : 소스.cpp, 크기:885
2022-03-21 11:57:28 GMT+9
 저장 시간 : 2022-03-21 11:57:28 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// 자원 관리 
struct Dog
{
	Dog() { cout << " Dog 생성" << endl; }
	~Dog() { cout << " Dog 소멸" << endl; }
};
void f() {
	throw 1;
}
int main() {

	save("소스.cpp");
	Dog* dogs = new Dog[3];
	
	// dogs를 신나게 사용

	// 비상상황 f()에서 예외 발생
	f();
	

	delete[] dogs;

}

파일 정보 : 소스.cpp, 크기:988
2022-03-21 11:59:49 GMT+9
 저장 시간 : 2022-03-21 11:59:49 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

// 자원 관리 
struct Dog
{
	Dog() { cout << " Dog 생성" << endl; }
	~Dog() { cout << " Dog 소멸" << endl; }
};
void f() {
	//throw 1;
}
int main() {

	Dog* dogs = new Dog[3];
	
	// dogs를 신나게 사용

	// 비상상황 f()에서 예외 발생
	try {
	f();
	}
	catch (...) {
		cout << " 예외를 잘 잡았다." << endl;
		delete[] dogs;
		return 0;
	}

	save("소스.cpp");
	delete[] dogs;

}

파일 정보 : 소스.cpp, 크기:965
2022-03-21 12:04:12 GMT+9
 저장 시간 : 2022-03-21 12:04:12 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include<memory>
#include "save.h"

using namespace std;

// 자원 관리 
struct Dog
{
	Dog() { cout << " Dog 생성" << endl; }
	~Dog() { cout << " Dog 소멸" << endl; }
};
void f() {
	//throw 1;
}
int main() {
	
	unique_ptr<Dog> dogs{new Dog[3]};

	// dogs를 신나게 사용

	// 비상상황 f()에서 예외 발생
	try {
		f();
	}
	catch (...) {
		cout << " 예외를 잘 잡았다." << endl;
		return 0;
	}

	save("소스.cpp");


}

파일 정보 : 소스.cpp, 크기:971
2022-03-21 12:05:58 GMT+9
 저장 시간 : 2022-03-21 12:05:58 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include<memory>
#include "save.h"

using namespace std;

// 자원 관리 
struct Dog
{
	Dog() { cout << " Dog 생성" << endl; }
	~Dog() { cout << " Dog 소멸" << endl; }
};
void f() {
	//throw 1;
}
int main() {
	
	unique_ptr<Dog[]> dogs{new Dog[3]};

	// dogs를 신나게 사용

	// 비상상황 f()에서 예외 발생
	try {
		f();
	}
	catch (...) {
		cout << " 예외를 잘 잡았다." << endl;
		return 0;
	}
	
		save("소스.cpp");
		

}

파일 정보 : 소스.cpp, 크기:1041
2022-03-21 12:12:20 GMT+9
 저장 시간 : 2022-03-21 12:12:20 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//		
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
//-----------------------------------------------------------------------------

#include<iostream>
#include<memory>
#include "save.h"

using namespace std;

// 자원 관리 
struct Dog
{
	Dog() { cout << " Dog 생성" << endl; }
	~Dog() { cout << " Dog 소멸" << endl; }
};
void f() {
	throw 1;
}
int main() {
	
	save("소스.cpp");
	
	unique_ptr<Dog[]> dogs{new Dog[3]};

	cout <<" 유니크 포인터의 메모리 크기 - " << sizeof(dogs) << endl;
	// dogs를 신나게 사용
	dogs[1];

	// 비상상황 f()에서 예외 발생
	try {
		f();
	}
	catch (...) {
		cout << " 예외를 잘 잡았다." << endl;
		return 0;
	}
}

파일 정보 : 소스.cpp, 크기:1089
2022-03-21 12:16:17 GMT+9
 저장 시간 : 2022-03-21 12:16:17 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//			
// 
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
// 
//		찾아보기 - RAII / Stack unwinding
//-----------------------------------------------------------------------------

#include<iostream>
#include<memory>
#include "save.h"

using namespace std;

// 자원 관리 
struct Dog
{
	Dog() { cout << " Dog 생성" << endl; }
	~Dog() { cout << " Dog 소멸" << endl; }
};
void f() {
	throw 1;
}
int main() {
	
	save("소스.cpp");
	
	unique_ptr<Dog[]> dogs{new Dog[3]};

	cout <<" 유니크 포인터의 메모리 크기 - " << sizeof(dogs) << endl;
	// dogs를 신나게 사용
	dogs[1];

	// 비상상황 f()에서 예외 발생
	try {
		f();
	}
	catch (...) {
		cout << " 예외를 잘 잡았다." << endl;
		return 0;
	}
}
파일 정보 : 소스.cpp, 크기:968

2022-03-22 20:08:29 GMT+9
 저장 시간 : 2022-03-22 20:08:29 GMT+9

//-----------------------------------------------------------------------------
//2022.3.21  월34                    월23수34                          (3주 1일)
//
//		지난시간 - int[10](바보 배열) 대신 array<int,100>을 사용하자.
//		오늘 - int* (raw pointer) 대신 unique_ptr<int>를 사용하자.
//			
// 
//		컴파일러가 값을 결정하는 경우는 2가지 시점 
//			1. 컴파일 타임(compile time)
//			2.실행 시간(run time)
// 
//		찾아보기 - RAII / Stack unwinding
// 
//		다시보기---------------------------------
// 
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include "save.h"

using namespace std;


// [문제] 파일 "int 천개.txt" - int 값 1000개가 바이너리모드로 write()함수로 기록
// 읽어서 최대값을 화면에 출력하시오,

int main() {

	ifstream in{ "int 천개.txt",ios::binary };

	//여기에 들어갈 코드를 답지에 적어라

	array<int, 1000> num;                      //int num[1000]; 사용하지 말자.
	in.read((char*)num.data(), sizeof(int) * 1000);
	cout << *max_element(begin(num), end(num)) << endl;


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:747
2022-03-23 11:46:55 GMT+9
 저장 시간 : 2022-03-23 11:46:55 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

//[문제] "소스.cpp"를 읽어
//			소문자를 대문자로 변경하여,
//			"소스 대문자.cpp"에 저장하라.
 
int main() {

	ifstream in{ "소스.cpp" };
	
	char ch;

	while (in >> ch)
		cout << ch;

	save("소스.cpp");

}

//내가 처리해야할 데이터 - container  같은 타입의 데이터를 담도록, 파일 정보 : 소스.cpp, 크기:763
2022-03-23 11:47:49 GMT+9
 저장 시간 : 2022-03-23 11:47:49 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

//[문제] "소스.cpp"를 읽어
//			소문자를 대문자로 변경하여,
//			"소스 대문자.cpp"에 저장하라.
 
int main() {

	ifstream in{ "소스.cpp" };
	
	char ch;
	in >> noskipws;
	while (in >> ch)
		cout << ch;

	save("소스.cpp");

}

//내가 처리해야할 데이터 - container  같은 타입의 데이터를 담도록, 파일 정보 : 소스.cpp, 크기:811
2022-03-23 11:49:36 GMT+9
 저장 시간 : 2022-03-23 11:49:36 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

//[문제] "소스.cpp"를 읽어
//			소문자를 대문자로 변경하여,
//			"소스 대문자.cpp"에 저장하라.
 
int main() {

	ifstream in{ "소스.cpp" };
	
	char ch;
	in >> noskipws;

	while (in >> ch) {
		if (islower(ch))
			ch = toupper(ch);
		cout << ch;
	}
	save("소스.cpp");

}

//내가 처리해야할 데이터 - container  같은 타입의 데이터를 담도록, 파일 정보 : 소스.cpp, 크기:790
2022-03-23 11:50:20 GMT+9
 저장 시간 : 2022-03-23 11:50:20 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

//[문제] "소스.cpp"를 읽어
//			소문자를 대문자로 변경하여,
//			"소스 대문자.cpp"에 저장하라.
 
int main() {

	ifstream in{ "소스.cpp" };
	
	char ch;
	in >> noskipws;

	while (in >> ch) {
		ch = toupper(ch);
		cout << ch;
	}
	save("소스.cpp");

}

//내가 처리해야할 데이터 - container  같은 타입의 데이터를 담도록, 파일 정보 : 소스.cpp, 크기:823
2022-03-23 11:51:55 GMT+9
 저장 시간 : 2022-03-23 11:51:55 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include "save.h"

using namespace std;

//[문제] "소스.cpp"를 읽어
//			소문자를 대문자로 변경하여,
//			"소스 대문자.cpp"에 저장하라.
 
int main() {

	ifstream in{ "소스.cpp" };
	ofstream out{ "소스 대문자.cpp" };
	char ch;
	in >> noskipws;

	while (in >> ch) {
		ch = toupper(ch);
		out << ch;
	}
	save("소스.cpp");

}

//내가 처리해야할 데이터 - container  같은 타입의 데이터를 담도록, 파일 정보 : 소스.cpp, 크기:878
2022-03-23 12:02:01 GMT+9
 저장 시간 : 2022-03-23 12:02:01 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] "소스.cpp"를 읽어
//			소문자를 대문자로 변경하여,
//			"소스 대문자.cpp"에 저장하라.
 
int main() {

	ifstream in{ "소스.cpp" };
	ofstream out{ "소스 대문자.cpp" };
	
	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out}, [](char c) {
		return toupper(c); 
		});

	save("소스.cpp");
}

//내가 처리해야할 데이터 - container  같은 타입의 데이터를 담도록, 파일 정보 : 소스.cpp, 크기:880
2022-03-23 12:19:32 GMT+9
 저장 시간 : 2022-03-23 12:19:32 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include "save.h"

using namespace std;

//[문제] 랜덤 int 100개를  생성하고 
// 오름차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid;

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" :20", number);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:882
2022-03-23 12:19:51 GMT+9
 저장 시간 : 2022-03-23 12:19:51 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include "save.h"

using namespace std;

//[문제] 랜덤 int 100개를  생성하고 
// 오름차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid;

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:20}", number);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:882
2022-03-23 12:20:08 GMT+9
 저장 시간 : 2022-03-23 12:20:08 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include "save.h"

using namespace std;

//[문제] 랜덤 int 100개를  생성하고 
// 오름차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid;

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:19}", number);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1070
2022-03-23 12:21:35 GMT+9
 저장 시간 : 2022-03-23 12:21:35 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 랜덤 int 100개를  생성하고 
// 오름차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid;

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:19}", number);

	sort(numbers.begin(), numbers.end());

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:19}", number);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1092
2022-03-23 12:22:52 GMT+9
 저장 시간 : 2022-03-23 12:22:52 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 오름차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:19}", number);

	sort(numbers.begin(), numbers.end());

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:19}", number);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1091
2022-03-23 12:23:09 GMT+9
 저장 시간 : 2022-03-23 12:23:09 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 오름차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	sort(numbers.begin(), numbers.end());

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:19}", number);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1100
2022-03-23 12:35:54 GMT+9
 저장 시간 : 2022-03-23 12:35:54 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 내림차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	sort(numbers.begin(), numbers.end(),greater());

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1165
2022-03-23 12:44:11 GMT+9
 저장 시간 : 2022-03-23 12:44:11 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 내림차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	sort(numbers.begin(), numbers.end(), [](int a, int b)
		{
			return a > b;
		});

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	save("소스.cpp");
}
//contiguos memory --> O(1)
파일 정보 : 소스.cpp, 크기:1283
2022-03-23 12:45:32 GMT+9
 저장 시간 : 2022-03-23 12:45:32 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 내림차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	sort(numbers.begin(), numbers.end(), [](int a, int b)
		{
			return a > b;
		}); // 알고리즘             sort(시작점, 끝점, 어떻게?)  기준을 알려주면 generic한 함수, 자료형에 상관없이 모든지 다가능,

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	save("소스.cpp");
}
//contiguos memory --> O(1)
파일 정보 : 소스.cpp, 크기:1283
2022-03-23 12:51:03 GMT+9
 저장 시간 : 2022-03-23 12:51:03 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 내림차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);
	
	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	sort(numbers.begin(), numbers.end(), [](int a, int b)
		{
			return a > b;
		}); // 알고리즘             sort(시작점, 끝점, 어떻게?)  기준을 알려주면 generic한 함수, 자료형에 상관없이 모든지 다가능,

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	save("소스.cpp");
}
//contiguos memory --> O(1)
파일 정보 : 소스.cpp, 크기:558
2022-03-23 12:53:00 GMT+9
 저장 시간 : 2022-03-23 12:53:00 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;
int f(int a, int b) { return a + b; }
int main() {
	int result = f(1, 2);
	cout << result << endl;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:580
2022-03-23 12:55:04 GMT+9
 저장 시간 : 2022-03-23 12:55:04 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;
int f(int a, int b) { return a + b; }
int main() {

	auto x = f;

	int result = x(1, 2);

	cout << result << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:576
2022-03-23 12:56:50 GMT+9
 저장 시간 : 2022-03-23 12:56:50 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

void f() { cout << " 함수 호출됨 " << endl; }

int main() {

	auto x = f;;
	x();
	cout << sizeof(x) << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:560
2022-03-23 12:57:44 GMT+9
 저장 시간 : 2022-03-23 12:57:44 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

void f() { cout << " 함수 호출됨 " << endl; }

int main() {

	auto x = f;;
	x();
	typeid(x);
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:583
2022-03-23 12:58:35 GMT+9
 저장 시간 : 2022-03-23 12:58:35 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

void f() { cout << " 함수 호출됨 " << endl; }

int main() {

	auto x = f;;
	x();
	cout << typeid(x).name ()<< endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:615
2022-03-23 12:59:04 GMT+9
 저장 시간 : 2022-03-23 12:59:04 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

void f() { cout << " 함수 호출됨 " << endl; }

int main() {

	auto x = f;;
	x();
	cout << typeid(x).name ()<< endl;
	cout << addressof(x) << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:558
2022-03-23 13:01:21 GMT+9
 저장 시간 : 2022-03-23 13:01:21 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

void f() { cout << " 함수 호출됨 " << endl; }

int main() {
	
	void (*x)( void)= f;
	
	x();

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1251
2022-03-23 13:08:59 GMT+9
 저장 시간 : 2022-03-23 13:08:59 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 내림차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int main() {
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);

	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	sort(numbers.begin(), numbers.end(), [](int a, int b)
		{
			return a > b;
		}); // 알고리즘             sort(시작점, 끝점, 어떻게?)  기준을 알려주면 generic한 함수, 자료형에 상관없이 모든지 다가능,

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	save("소스.cpp");
}

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//  오늘 - 호출 가능 타입(callable type) - 정렬 (sort)
//	자원을 관리하는 클래스 - STRING - 컨테이너, 반복자, 알고리즘
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<array>
#include<format>
#include<algorithm>
#include "save.h"

using namespace std;

//[문제] 값이 [1,100] 랜덤 int 100개를  생성하고 
// 내림차순으로 정렬한 후
// 정렬된 int 100개를 화면에 출력하시오.

default_random_engine dre;
uniform_int_distribution uid{ 1,100 };

int game(int a, int b)
{
	return a > b;
}

class Dog {
public:
	void operator()(void) {
		cout << " 나도 부를 수 있음 " << endl;
	}
};

int main() {

	Dog dog;
	dog();

	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);

	cout << " 정렬 전 -- " << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	sort(numbers.begin(), numbers.end(), game);

	cout << endl << endl;
	cout << " 정렬 후 --" << endl;
	for (int number : numbers)
		cout << format(" {:4}", number);

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:673
2022-03-28 10:37:47 GMT+9
 저장 시간 : 2022-03-28 10:37:47 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 

void f()
{
	cout << "점프" << endl;
}

int main() {

	save("소스.cpp");

	while (true) {
		f();					//이 게임은 f() 만 호출
		using namespace std::literals;
		this_thread::sleep_for(1s);
	}


}파일 정보 : 소스.cpp, 크기:641
2022-03-28 10:38:08 GMT+9
 저장 시간 : 2022-03-28 10:38:08 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 

void f()
{
	cout << "점프" << endl;
}

int main() {

	save("소스.cpp");

	while (true) {
		f();					//이 게임은 f() 만 호출

		this_thread::sleep_for(1s);
	}


}파일 정보 : 소스.cpp, 크기:861
2022-03-28 10:48:58 GMT+9
 저장 시간 : 2022-03-28 10:48:58 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 

void jump()
{
	cout << "점프" << endl;
}
void slide()
{
	cout << "슬라이드" << endl;
}

int main() {

	save("소스.cpp");

	auto f = jump;
	int cnt{};

	while (true) {
		f();					//이 게임은 f() 만 호출

		this_thread::sleep_for(1s);

		// 3초마다 설정이 바귄다고 가정하자.
		if ((++cnt % 3 == 0)) {
			if (f == jump)
				f = slide;
			else
				f = jump;
		}
	}


}
파일 정보 : 소스.cpp, 크기:886
2022-03-28 10:54:35 GMT+9
 저장 시간 : 2022-03-28 10:54:35 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 

void jump()
{
	cout << "점프" << endl;
}
void slide()
{
	cout << "슬라이드" << endl;
}

int main() {

	save("소스.cpp");

	auto f = jump;				//함수의 주소를 저장,
	int cnt{};

	while (true) {
		f();					//이 게임은 f() 만 호출

		this_thread::sleep_for(1s);

		// 3초마다 설정이 바귄다고 가정하자.
		if ((++cnt % 3 == 0)) {
			if (f == jump)
				f = slide;
			else
				f = jump;
		}
	}


}
파일 정보 : 소스.cpp, 크기:715
2022-03-28 10:55:40 GMT+9
 저장 시간 : 2022-03-28 10:55:40 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 

void jump()
{
	cout << "점프" << endl;
}
void slide()
{
	cout << "슬라이드" << endl;
}

int main() {

	save("소스.cpp");

	auto f = jump;				//함수의 주소를 저장,

	cout << sizeof(f) << endl;
	cout << typeid(f).name() << endl;


}
파일 정보 : 소스.cpp, 크기:743
2022-03-28 10:58:36 GMT+9
 저장 시간 : 2022-03-28 10:58:36 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 

void jump()
{
	cout << "점프" << endl;
}
void slide()
{
	cout << "슬라이드" << endl;
}

int main() {

	save("소스.cpp");

	void (*f)(void) = (void (*)(void))( jump);				//함수의 주소를 저장,

	cout << sizeof(f) << endl;
	cout << typeid(f).name() << endl;


}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}


}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:24 GMT+9
 저장 시간 : 2022-03-28 11:01:24 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:25 GMT+9
 저장 시간 : 2022-03-28 11:01:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}

2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
using namespace std;


2022-03-28 11:01:26
	int(*f)() = main;


//게임 - 설정 - 버튼의 기주 2일)
//
//-------------------------------------------------------------------
	int(*f)() = mai-------

#include<iostream>
#include<th
	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:26 GMT+9
 저장 시간 : 2022-03-28 11:01:26 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}
파일 정보 : 소스.cpp, 크기:564
2022-03-28 11:01:27 GMT+9
 저장 시간 : 2022-03-28 11:01:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//프로그램의 기능을 담당 - 서브루틴, 함수 
//프로그램이 실행될 때 기능을 변경하고 싶다. 

//게임 - 설정 - 버튼의 기능변경 


int main() {

	save("소스.cpp");
	cout << "메인 " << " ";

	int(*f)() = main;

	f();

}

파일 정보 : 소스.cpp, 크기:564
파일 정보 : 소스.cpp, 크기:571
2022-03-28 11:05:48 GMT+9
 저장 시간 : 2022-03-28 11:05:48 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터


int main() {

	[]() {};
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:633
2022-03-28 11:06:20 GMT+9
 저장 시간 : 2022-03-28 11:06:20 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터


int main() {

	[]() {
		cout << "안녕, 난 람다라고해, 만나서 반가워" << endl;
	}();
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:667
2022-03-28 11:12:21 GMT+9
 저장 시간 : 2022-03-28 11:12:21 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터


int main() {

	cout << typeid([]() {
		cout << "안녕, 난 람다라고해, 만나서 반가워" << endl;	
		}).name() << endl;
	
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:685
2022-03-28 11:13:16 GMT+9
 저장 시간 : 2022-03-28 11:13:16 GMT+9

//-----------------------------------------------------------------------------
//2022.3.23  월34                    월23수34                          (3주 2일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터


int main() {

		auto x = []() {
		cout << "안녕, 난 람다라고해, 만나서 반가워" << endl;	
		};

		cout << typeid(x).name() << endl;
	
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:630
2022-03-28 11:18:58 GMT+9
 저장 시간 : 2022-03-28 11:18:58 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터


int main() {

	class Dog {};

	cout << typeid(Dog).name() << endl;

	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:629
2022-03-28 11:19:40 GMT+9
 저장 시간 : 2022-03-28 11:19:40 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터

class Dog {};

int main() {


	cout << typeid(Dog).name() << endl;

	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:628
2022-03-28 11:21:03 GMT+9
 저장 시간 : 2022-03-28 11:21:03 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터


int main() 
{
	auto x = []() {};
	cout << typeid(x).name() << endl;
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:627
2022-03-28 11:21:15 GMT+9
 저장 시간 : 2022-03-28 11:21:15 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<thread>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터


auto x = []() {};
int main() 
{
	cout << typeid(x).name() << endl;
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:807
2022-03-28 11:24:50 GMT+9
 저장 시간 : 2022-03-28 11:24:50 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
//						??? 이름없는데 누가 어떻게 불러 쓰나?
// 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터



int main() 
{
	array<int, 5>a{ 1,2,3,4,5 };
	sort(a.begin(), a.end(), [](int a, int b) {
		return a > b;
		});
	for (int n : a)
		cout << n << " ";
	cout << endl;

	
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:882
2022-03-28 11:28:58 GMT+9
 저장 시간 : 2022-03-28 11:28:58 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
//						??? 이름없는데 누가 어떻게 불러 쓰나?
// 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터



int main() 
{
	
	

	array<int, 5>a{ 1,3,5,2,4 };

	/*sort(반복자b, 반복자e..호출가능타입 f) {
		f(a, b);
	}*/

	sort(a.begin(), a.end(), [](int a, int b) {
		return a > b;
		});

	for (int n : a)
		cout << n << " ";
	cout << endl;

	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:882
2022-03-28 11:29:06 GMT+9
 저장 시간 : 2022-03-28 11:29:06 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
//						??? 이름없는데 누가 어떻게 불러 쓰나?
// 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터



int main() 
{
	
	

	array<int, 5>a{ 1,3,5,2,4 };

	/*sort(반복자b, 반복자e..호출가능타입 f) {
		f(a, b);
	}*/

	sort(a.begin(), a.end(), [](int a, int b) {
		return a < b;
		});

	for (int n : a)
		cout << n << " ";
	cout << endl;

	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:933
2022-03-28 11:29:49 GMT+9
 저장 시간 : 2022-03-28 11:29:49 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
//						??? 이름없는데 누가 어떻게 불러 쓰나?
// 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터



int main() 
{
	
	

	array<int, 5>a{ 1,3,5,2,4 };

	/*sort(반복자b, 반복자e..호출가능타입 f) {
		f(a, b);
	}*/

	sort(a.begin(), a.end(), [](int a, int b) {
		cout << " 내림차순" << a << " - " << b << endl;
		return a > b;
		});

	for (int n : a)
		cout << n << " ";
	cout << endl;

	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:910
2022-03-28 11:34:43 GMT+9
 저장 시간 : 2022-03-28 11:34:43 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
//						??? 이름없는데 누가 어떻게 불러 쓰나?
// 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터

class Dog {
public:
	bool operator()(int a, int b)
	{
		cout << "Dog의 멤버" << a << "<" << b << endl;
		return a < b;
	}
};

int main()
{



	array<int, 5>a{ 1,3,5,2,4 };

	sort(a.begin(), a.end(), Dog{});

	for (int n : a)
		cout << n << " ";
	cout << endl;

	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:913
2022-03-28 11:35:17 GMT+9
 저장 시간 : 2022-03-28 11:35:17 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
//						??? 이름없는데 누가 어떻게 불러 쓰나?
// 
// 3. ()를 오버로딩한 클래스 - 
// 4. 멤버함수포인터

class Dog {
public:
	bool operator()(int a, int b)
	{
		cout << "Dog의 멤버 " << a << " < " << b << endl;
		return a < b;
	}
};

int main()
{



	array<int, 5>a{ 1,3,5,2,4 };

	sort(a.begin(), a.end(), Dog{});

	for (int n : a)
		cout << n << " ";
	cout << endl;

	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:890
2022-03-28 11:50:51 GMT+9
 저장 시간 : 2022-03-28 11:50:51 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//-----------------------------------------------------------------------------

#include<iostream>
#include<functional>
#include "save.h"

using namespace std;


//호출가능(callable) 타입(type)
// 1.  함수포인터 - 함수의 시작번지를 저장할 수 있다.
// 2. 람다(lambda) - 이름없는 함수 부를 수 없는
//						??? 이름없는데 누가 어떻게 불러 쓰나?
// 
// 3. ()를 오버로딩한 클래스 - functor
// 4. 멤버함수포인터

// 호출가능한 타입의 종류?   - 무한 

// function - 어떤 호출가능한 타입이더라도 function 객체로 대표할 수 있다. 

void jump() { cout << "점프" << endl; }
void slide() { cout << "슬라이드" << endl; }
int main()
{
	function<void()> f = jump;
	f();
	f = slide;
	f();
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1830
파일 정보 : 소스.cpp, 크기:1770
파일 정보 : 소스.cpp, 크기:1770
2022-03-30 11:45:43 GMT+9
 저장 시간 : 2022-03-30 11:45:43 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING{
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}

	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{

	Check = true;
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	// STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	// cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1768
2022-03-30 11:47:54 GMT+9
 저장 시간 : 2022-03-30 11:47:54 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING{
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}

	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	save("소스.cpp");

	Check = true;
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	//STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	//cout << c << endl;

}파일 정보 : 소스.cpp, 크기:1863
2022-03-30 11:57:23 GMT+9
 저장 시간 : 2022-03-30 11:57:23 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING{
public:
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	STRING operator+(const STRING& s) const {
		STRING temp(p + s.id);
		return temp;
	}

	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	save("소스.cpp");

	Check = true;
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

}파일 정보 : 소스.cpp, 크기:1864
2022-03-30 11:59:33 GMT+9
 저장 시간 : 2022-03-30 11:59:33 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING{
public:
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	STRING operator+(const STRING& s) const {
		STRING temp(p + s.gid);
		return temp;
	}

	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	save("소스.cpp");

	Check = true;
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

}파일 정보 : 소스.cpp, 크기:1864
2022-03-30 11:59:45 GMT+9
 저장 시간 : 2022-03-30 11:59:45 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING{
public:
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	STRING operator+(const STRING& s) const {
		STRING temp(p + s.gid);
		return temp;
	}

	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	save("소스.cpp");

	Check = true;
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

}파일 정보 : 소스.cpp, 크기:2058
2022-03-30 12:08:14 GMT+9
 저장 시간 : 2022-03-30 12:08:14 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);
		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	save("소스.cpp");

	Check = true;
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

}파일 정보 : 소스.cpp, 크기:1984
2022-03-30 12:08:58 GMT+9
 저장 시간 : 2022-03-30 12:08:58 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	save("소스.cpp");
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	
	cout << a + b << endl;

}파일 정보 : 소스.cpp, 크기:2047
2022-03-30 12:09:25 GMT+9
 저장 시간 : 2022-03-30 12:09:25 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  월23                    월23수34                          (4주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	
	STRING a{ "2022. 3. 28 qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq" };
	STRING b{ "STL rrrrrrrrrrrrrrrrrrrrrrrrrrrrr" };
	
	cout << a + b << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:2045
2022-03-30 12:11:42 GMT+9
 저장 시간 : 2022-03-30 12:11:42 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING operator+(const STRING& rhs) const {

		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	
	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:2060
2022-03-30 12:12:04 GMT+9
 저장 시간 : 2022-03-30 12:12:04 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING operator+(const STRING& rhs) const {

		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	Check = true;

	STRING a{ "2022. 3. 28" };
	STRING b{ "STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:2062
2022-03-30 12:13:12 GMT+9
 저장 시간 : 2022-03-30 12:13:12 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING operator+(const STRING& rhs) const {

		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	Check = true;

	STRING a{ " 2022. 3. 28" };
	STRING b{ " STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:2473
2022-03-30 12:19:46 GMT+9
 저장 시간 : 2022-03-30 12:19:46 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING(const STRING& other) :id{ gid++ }, num{ other.num }, p{ new char[num] } {
		memcpy(p, other.p, num);
		if (Check)
			print("  복사 생성자 - (const char*)");

	}

	STRING& operator=(const STRING& other) {
		if (this == &other)
			return *this;
		num = other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, other.p, num);

		if (Check)
			print("복사 할당");

		return *this;
	}

	STRING operator+(const STRING& rhs) const {

		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	Check = true;

	STRING a{ " 2022. 3. 28" };
	STRING b{ " STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:2475
2022-03-30 12:20:14 GMT+9
 저장 시간 : 2022-03-30 12:20:14 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING(const STRING& other) :id{ gid++ }, num{ other.num }, p{ new char[num] } {
		memcpy(p, other.p, num);
		if (Check)
			print("  복사 생성자 - (const char*)");

	}

	STRING& operator=(const STRING& other) {
		if (this == &other)
			return *this;
		num = other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, other.p, num);

		if (Check)
			print("복사 할당");

		return *this;
	}

	STRING operator+(const STRING& rhs) const {

		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	//Check = true;

	STRING a{ " 2022. 3. 28" };
	STRING b{ " STL" };
	STRING c = a + b;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:2469
2022-03-30 12:20:37 GMT+9
 저장 시간 : 2022-03-30 12:20:37 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		delete[] p;
	}

	STRING(const STRING& other) :id{ gid++ }, num{ other.num }, p{ new char[num] } {
		memcpy(p, other.p, num);
		if (Check)
			print("  복사 생성자 - (const char*)");

	}

	STRING& operator=(const STRING& other) {
		if (this == &other)
			return *this;
		num = other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, other.p, num);

		if (Check)
			print("복사 할당");

		return *this;
	}

	STRING operator+(const STRING& rhs) const {

		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	Check = true;

	STRING a{ " 2022. 3. 28" };
	STRING b{ " STL" };
	STRING c = a;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:2482
2022-03-30 12:21:47 GMT+9
 저장 시간 : 2022-03-30 12:21:47 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

// [STL 관찰용 ] STRING 클래스를 작성한다.
// 자원을 관리하는 클래스이다. (RAII)
// 관찰을 위해 스페셜함수의 동작을 화면에 출력 할 수 있게 한다. 
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체가 생성시 고유번호를 부여

bool Check{ false };

class STRING {
	char* p;						//확보한 자원	주소 
	size_t num;					//관리하는 바이트
	int id;							//생성 시 부여한 id
	static int gid;					//클래스 스태틱 - id 관리 

public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (Check)
			print(" 디폴트 ");
	}

	STRING(const char* s) : id{ ++gid }, num { strlen(s) }, p{ new char[num] } {
		if (Check)
			print(" 생성자 - (const char*)");
		memcpy(p, s, num);
	}
	~STRING() {
		if (Check)
			print(" 소멸자 ");
		if (num)
			delete[] p;
	}

	STRING(const STRING& other) :id{ gid++ }, num{ other.num }, p{ new char[num] } {
		memcpy(p, other.p, num);
		if (Check)
			print("  복사 생성자 - (const char*)");

	}

	STRING& operator=(const STRING& other) {
		if (this == &other)
			return *this;
		num = other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, other.p, num);

		if (Check)
			print("복사 할당");

		return *this;
	}

	STRING operator+(const STRING& rhs) const {

		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << " ] 객체 주소:" << this << " 자원 - ";
		if (num != 0) {
			cout << " 개수 : " << num << " 주소 " << (void*)p << endl;
		}
		else
			cout << " 없음 " << endl;
	}

	friend ostream& operator << (ostream&, const STRING&);
};

int STRING::gid{};

ostream& operator << (ostream& os, const STRING& s) {
	for (int i{}; i < s.num; ++i)
	{
		os << s.p[i];
	}
	return os;
};

int main()
{
	Check = true;

	STRING a{ " 2022. 3. 28" };
	STRING b{ " STL" };
	STRING c = a;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:651
2022-03-30 12:46:50 GMT+9
 저장 시간 : 2022-03-30 12:46:50 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
#include "STRIG.h"
using namespace std;

extern bool Check;

int main()
{
	Check = true;

	STRING a{ " 2022. 3. 28" };
	STRING b{ " STL" };
	STRING c = a;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:650
2022-03-30 12:47:20 GMT+9
 저장 시간 : 2022-03-30 12:47:20 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"
#include "STRIG.h"
using namespace std;

extern bool Check;

int main()
{
	Check = false;
	STRING a{ " 2022. 3. 28" };
	STRING b{ " STL" };
	STRING c = a;
	
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:539
2022-03-30 12:50:27 GMT+9
 저장 시간 : 2022-03-30 12:50:27 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRIG.h"
using namespace std;

extern bool Check;

int main()
{
	array<STRING, 3> strs;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:555
2022-03-30 12:50:44 GMT+9
 저장 시간 : 2022-03-30 12:50:44 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRIG.h"
using namespace std;

extern bool Check;

int main()
{
	Check = true;
	array<STRING, 3> strs;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:555
2022-03-30 12:52:09 GMT+9
 저장 시간 : 2022-03-30 12:52:09 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
// 스페셜 함수, 꼭 공부하고오자
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRIG.h"
using namespace std;

extern bool Check;

int main()
{
	Check = true;
	array<STRING, 3> strs;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:526
2022-03-30 13:07:12 GMT+9
 저장 시간 : 2022-03-30 13:07:12 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRIG.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;

	STRING s{ "12345" };

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:537
2022-03-30 13:07:37 GMT+9
 저장 시간 : 2022-03-30 13:07:37 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRIG.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;

	STRING s{ "12345" };

	s = s;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:560
2022-03-30 13:08:33 GMT+9
 저장 시간 : 2022-03-30 13:08:33 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRIG.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;

	STRING s{ "12345" };
	STRING s2{ "67890" };
	s = s2;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:588
2022-03-30 13:09:58 GMT+9
 저장 시간 : 2022-03-30 13:09:58 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRIG.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	STRING s{ "12345" };
	STRING s2{ "1234567890" };

	s = s2;

	cout << s << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:589
2022-04-04 10:32:18 GMT+9
 저장 시간 : 2022-04-04 10:32:18 GMT+9

//-----------------------------------------------------------------------------
//2022.3.28  수 34                    월23수34                          (4주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	STRING s{ "12345" };
	STRING s2{ "1234567890" };

	s = s2;

	cout << s << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:562
2022-04-04 10:38:02 GMT+9
 저장 시간 : 2022-04-04 10:38:02 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:714
2022-04-04 10:40:44 GMT+9
 저장 시간 : 2022-04-04 10:40:44 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.
	for (STRING n : a) {
		cout << n << endl;
	}

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:884
2022-04-04 10:48:28 GMT+9
 저장 시간 : 2022-04-04 10:48:28 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.
	array<STRING, 3>::iterator p = a.begin();
	// 반복자 , 포인터를 추상화해서 만든 디자인패턴 
	//C++ 라이브러리는 반복자를 제공하는데 이것을 사용하면 라이브러리의 방식대로 자료구조를 액세스 할 수 있다.
	//따라서 라이브러리가 효과적으로 동작한다는 것을 보장 할 수 있다는 장점이 있다.

	cout << *p << endl; // 역참조가 가능
	++p;
	cout << *p << endl;
	++p;
	cout << *p << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:784
2022-04-04 10:51:53 GMT+9
 저장 시간 : 2022-04-04 10:51:53 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.
	for (array<STRING, 3>::iterator i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:762
2022-04-04 10:52:37 GMT+9
 저장 시간 : 2022-04-04 10:52:37 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.
	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:818
2022-04-04 10:54:02 GMT+9
 저장 시간 : 2022-04-04 10:54:02 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	*a.begin() = "fesefsfsefs";

	for (array<STRING, 3>::iterator i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:813
2022-04-04 10:54:57 GMT+9
 저장 시간 : 2022-04-04 10:54:57 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	for (array<STRING, 3>::const_iterator i = a.cbegin(); i != a.end(); ++i) // 읽기만 가능 하게
		cout << *i << endl;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:819
2022-04-04 10:55:21 GMT+9
 저장 시간 : 2022-04-04 10:55:21 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	for (auto i = a.cbegin(); i != a.end(); ++i) // 읽기만 가능 하게 이런 자료형들이 이해되면 auto사용
		cout << *i << endl;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:752
2022-04-04 10:56:15 GMT+9
 저장 시간 : 2022-04-04 10:56:15 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	for (STRING s : a)
		cout << s << endl;				//꿀문법

	save("소스.cpp");
}
}파일 정보 : 소스.cpp, 크기:812
2022-04-04 10:58:24 GMT+9
 저장 시간 : 2022-04-04 10:58:24 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	for (STRING s : a)
		cout << s << endl;				// 이짓하면안됨 값을 찍기 위해 복사생성자 3개를 추가로 만듬 메모리낭비

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:748
2022-04-04 10:59:03 GMT+9
 저장 시간 : 2022-04-04 10:59:03 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	for (const STRING& s : a)		//const와 & 하여 복사를 하지 않게 
		cout << s << endl;			

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:768
2022-04-04 11:03:41 GMT+9
 저장 시간 : 2022-04-04 11:03:41 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	for (int i = 0; i < a.size(); ++i)
		cout << a.operator[](i) << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:757
2022-04-04 11:04:07 GMT+9
 저장 시간 : 2022-04-04 11:04:07 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서
	// 값을 출력하라.

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:790
2022-04-04 11:09:47 GMT+9
 저장 시간 : 2022-04-04 11:09:47 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	array<STRING, 3> a{ "컨테이너", "반복자", "알고리즘" };   // size는 STRING[3]과 같다.

	// [문제] a에 들어있는 원소(element)를 역방향으로 순회(iteration)하면서
	// 값을 출력하라.
	

	//rend() -> adaptor  
	for (auto i = a.crbegin(); i != a.crend(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:781
2022-04-04 11:19:23 GMT+9
 저장 시간 : 2022-04-04 11:19:23 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	// [문제] array a 를 길이 오름차순으로 정렬하고 결과를 출력하라.

	array<STRING, 3> a{ "12345", "33", "12345432331" };   // size는 STRING[3]과 같다.

	sort(a.begin(), a.end(), [](STRING a, STRING b) {
		return a.getNum() < b.getNum();
		});


	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:841
2022-04-04 11:19:44 GMT+9
 저장 시간 : 2022-04-04 11:19:44 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	// [문제] array a 를 길이 오름차순으로 정렬하고 결과를 출력하라.

	array<STRING, 3> a{ "12345", "33", "12345432331" };   // size는 STRING[3]과 같다.

	sort(a.begin(), a.end(), [](STRING a, STRING b) {
		return a.getNum() < b.getNum();
		});

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:839
2022-04-04 11:20:06 GMT+9
 저장 시간 : 2022-04-04 11:20:06 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	// [문제] array a 를 길이 오름차순으로 정렬하고 결과를 출력하라.

	array<STRING, 3> a{ "12345", "33", "12345432331" };   // size는 STRING[3]과 같다.

	sort(a.begin(), a.end(), [](STRING a, STRING b) {
		return a.getNum() < b.getNum();
		});

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:853
2022-04-04 11:33:13 GMT+9
 저장 시간 : 2022-04-04 11:33:13 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	// [문제] array a 를 길이 오름차순으로 정렬하고 결과를 출력하라.

	array<STRING, 3> a{ "12345", "33", "12345432331" };   // size는 STRING[3]과 같다.

	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:853
2022-04-04 11:34:52 GMT+9
 저장 시간 : 2022-04-04 11:34:52 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	Check = true;
	
	// [문제] array a 를 길이 오름차순으로 정렬하고 결과를 출력하라.

	array<STRING, 3> a{ "12345", "33", "12345432331" };   // size는 STRING[3]과 같다.

	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() > b.getNum();
		});

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:855
2022-04-04 11:35:00 GMT+9
 저장 시간 : 2022-04-04 11:35:00 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//Check = true;
	
	// [문제] array a 를 길이 오름차순으로 정렬하고 결과를 출력하라.

	array<STRING, 3> a{ "12345", "33", "12345432331" };   // size는 STRING[3]과 같다.

	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() > b.getNum();
		});

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:589
2022-04-04 11:38:48 GMT+9
 저장 시간 : 2022-04-04 11:38:48 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체들을 관리하는 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{	
	int a[10];
	cout << a[-1] << endl;
	cout << a[10] << endl;
	
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:762
2022-04-04 11:41:55 GMT+9
 저장 시간 : 2022-04-04 11:41:55 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체들을 관리하는 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	int a[10]{ 0,1,2,3,4,5,6,7,8,9 };

	cout << a[-1] << endl;
	cout << a[10] << endl;

	save("소스.cpp");

	while (true) {
		int num;
		cout << "몇 번 값을 원하시나요?" << endl;
		cin >> num;

		cout << num << "번 값은 -" << a[num] << endl;
	}
}파일 정보 : 소스.cpp, 크기:717
2022-04-04 11:43:50 GMT+9
 저장 시간 : 2022-04-04 11:43:50 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체들을 관리하는 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
array<int,10>a{ 0,1,2,3,4,5,6,7,8,9 };

	
	save("소스.cpp");

	while (true) {
		int num;
		cout << "몇 번 값을 원하시나요?" << endl;
		cin >> num;

		cout << num << "번 값은 -" << a[num] << endl;
	}
}파일 정보 : 소스.cpp, 크기:722
2022-04-04 11:45:34 GMT+9
 저장 시간 : 2022-04-04 11:45:34 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체들을 관리하는 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	array<int,10>a{ 0,1,2,3,4,5,6,7,8,9 };

	
	save("소스.cpp");

	while (true) {
		int num;
		cout << "몇 번째 값을 원하시나요?" << endl;
		cin >> num;

		cout << num << "번 값은 - " << a.at(num) << endl;
	}
}파일 정보 : 소스.cpp, 크기:798
2022-04-04 11:47:56 GMT+9
 저장 시간 : 2022-04-04 11:47:56 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체들을 관리하는 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	array<int,10>a{ 0,1,2,3,4,5,6,7,8,9 };

	
	save("소스.cpp");

	while (true) {
		int num;
		cout << "몇 번째 값을 원하시나요?" << endl;
		cin >> num;

		try {
			cout << num << "번째 값은 - " << a.at(num) << endl;
		}
		catch (exception& e) {
			cout << e.what() << endl;
		}
	}
}파일 정보 : 소스.cpp, 크기:822
2022-04-04 11:48:37 GMT+9
 저장 시간 : 2022-04-04 11:48:37 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체들을 관리하는 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	array<int,10>a{ 0,1,2,3,4,5,6,7,8,9 };

	
	save("소스.cpp");

	while (true) {
		int num;
		cout << "몇 번째 값을 원하시나요?" << endl;
		cin >> num;

		try {
			cout << num << "번째 값은 - " << a.at(num) << endl;
		}
		catch (exception& e) {
			cout << " 0 - 9 까지 숫자를 입력하시오." << endl;
		}
	}
}파일 정보 : 소스.cpp, 크기:780
2022-04-04 11:53:01 GMT+9
 저장 시간 : 2022-04-04 11:53:01 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<char> v;

	v.push_back('S');
	v.push_back('T');
	v.push_back('L');

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:886
2022-04-04 11:58:29 GMT+9
 저장 시간 : 2022-04-04 11:58:29 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] "소스.cpp"의 char를 v에  모두 저장 (공백 포함)

	vector<char> v;
	
	ifstream in{ "소스.cpp" };
	noskipws(in);
	char c;
	while (in >> c)
		v.push_back(c);

	for (int i = 0; i < v.size(); ++i)
		cout << v[i];

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:889
2022-04-04 11:59:02 GMT+9
 저장 시간 : 2022-04-04 11:59:02 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] "소스.cpp"의 char를 v에  모두 저장 (공백 포함)

	vector<char> v;
	
	ifstream in{ "소스.cpp" };
	in >> noskipws;;
	char c;
	while (in >> c)
		v.push_back(c);

	for (int i = 0; i < v.size(); ++i)
		cout << v[i];

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:899
2022-04-04 12:00:14 GMT+9
 저장 시간 : 2022-04-04 12:00:14 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] "소스.cpp"의 char를 v에  모두 저장 (공백 포함)

	vector<char> v;
	
	ifstream in{ "소스.cpp" };
	in >> noskipws;;
	char c;
	while (in >> c)
		v.push_back(toupper (c));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i];

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:909
2022-04-04 12:01:53 GMT+9
 저장 시간 : 2022-04-04 12:01:53 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] "소스.cpp"의 단어를 v에  모두 저장 (공백 포함)

	vector<string> v;
	
	ifstream in{ "소스.cpp" };
	
	string str;
	while (in >> str)
		v.push_back(str);

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << "\t";

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:961
2022-04-04 12:19:12 GMT+9
 저장 시간 : 2022-04-04 12:19:12 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << " ";
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:961
2022-04-04 12:19:29 GMT+9
 저장 시간 : 2022-04-04 12:19:29 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << " ";
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:962
2022-04-04 12:20:08 GMT+9
 저장 시간 : 2022-04-04 12:20:08 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << endl;
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:962
2022-04-06 00:45:34 GMT+9
 저장 시간 : 2022-04-06 00:45:34 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << endl;
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:962
2022-04-06 00:47:49 GMT+9
 저장 시간 : 2022-04-06 00:47:49 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << endl;
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:991
2022-04-06 00:54:37 GMT+9
 저장 시간 : 2022-04-06 00:54:37 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << endl;
	cout << sizeof(v) << endl;
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:991
2022-04-06 00:54:50 GMT+9
 저장 시간 : 2022-04-06 00:54:50 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << endl;
	cout << sizeof(v) << endl;
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:991
2022-04-06 00:55:35 GMT+9
 저장 시간 : 2022-04-06 00:55:35 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << endl;
	cout << sizeof(v) << endl;
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:991
2022-04-06 00:55:54 GMT+9
 저장 시간 : 2022-04-06 00:55:54 GMT+9

//-----------------------------------------------------------------------------
//2022.4.4  월 23                    월23수34                          (5주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array 
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	//[문제] 키보드에서 입력하는 모든 단어를 받는다. 
	// 오름차순으로 정렬한다. 
	// 결과를 출력한다.

	vector<string> v;

	string str;
	while (cin >> str)
		v.push_back(str);
	sort(v.begin(), v.end());

	for (const string& s : v)
		cout << s << endl;
	cout << sizeof(v) << endl;
	
	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:975
2022-04-06 12:09:46 GMT+9
 저장 시간 : 2022-04-06 12:09:46 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<int> v1;
	vector<int> v2;

	

	// vector<int>가 제공하는 자료형	- 		vector<int>::value_type
	// v가 제공하는 함수 멤버	 - v.push_back();
	// 컨테이너간에 적용되는 연산	 - 	v2 = v1;

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:927
2022-04-06 12:11:20 GMT+9
 저장 시간 : 2022-04-06 12:11:20 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<int> v1;
	
	cout << "현재 원소의 개수 : " << v1.size() << endl;
	cout << "v1이 저장할 수 있는 최대 원소 수 : " << v1.max_size() << endl;

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:960
2022-04-06 12:12:25 GMT+9
 저장 시간 : 2022-04-06 12:12:25 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<char> v1;
	
	cout << "현재 원소의 개수 : " << v1.size() << endl;
	cout << "v1이 저장할 수 있는 최대 원소 수 : " << v1.max_size() << endl;
	// int -  4611686018427387903

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:993
2022-04-06 12:13:33 GMT+9
 저장 시간 : 2022-04-06 12:13:33 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<int> v1;
	
	cout << "현재 원소의 개수 : " << v1.size() << endl;
	cout << "v1이 저장할 수 있는 최대 원소 수 : " << v1.max_size() << endl;
	// char - 9223372036854775807
	// int -	   4611686018427387903

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:975
2022-04-06 12:14:24 GMT+9
 저장 시간 : 2022-04-06 12:14:24 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<int> v;
	
	cout << "현재 원소의 개수 : " << v.size() << endl;
	cout << "벡터 v의 메모리 크기 : " << sizeof(v) << endl;
	// char - 9223372036854775807
	// int -	   4611686018427387903

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:975
2022-04-06 12:14:47 GMT+9
 저장 시간 : 2022-04-06 12:14:47 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<int> v;
	
	cout << "현재 원소의 개수 : " << v.size() << endl;
	cout << "벡터 v의 메모리 크기 : " << sizeof(v) << endl;
	// char - 9223372036854775807
	// int -	   4611686018427387903

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:849
2022-04-06 12:20:32 GMT+9
 저장 시간 : 2022-04-06 12:20:32 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<int> v{1,2,3};
	
	cout << "v의 원소수" << v.size() << endl;

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:867
2022-04-06 12:22:36 GMT+9
 저장 시간 : 2022-04-06 12:22:36 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector<int> v{1,2,3};
	v.push_back(4);
	cout << "v의 원소수 - " << v.size() << endl;

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:882
2022-04-06 12:24:18 GMT+9
 저장 시간 : 2022-04-06 12:24:18 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector v{1,2,3};
	cout << typeid(v).name() << endl;
	cout << "v의 원소수 - " << v.size() << endl;


	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:1064
2022-04-06 12:42:46 GMT+9
 저장 시간 : 2022-04-06 12:42:46 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector v{1,2,3};

	//[문제 ]  vector의 메모리가 확장되는 모습을 관찰하고 싶다.
	// - 원소를 하나씩 추가 하면서 벡터가 관리하는 메모리의 크기를 관찰 
	// - vector의 maxize?  
	
	cout << " 현재 원소 수 - " << v.size() << endl;
	cout << " 벡터의 용량 - " << v.capacity() << endl;

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:1189
2022-04-06 12:43:09 GMT+9
 저장 시간 : 2022-04-06 12:43:09 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>

#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	vector v{1,2,3};

	//[문제 ]  vector의 메모리가 확장되는 모습을 관찰하고 싶다.
	// - 원소를 하나씩 추가 하면서 벡터가 관리하는 메모리의 크기를 관찰 
	// - vector의 masize?  
	
	cout << " 현재 원소 수 - " << v.size() << endl;
	cout << " 벡터의 용량 - " << v.capacity() << endl;

	v.push_back(4);

	cout << " 현재 원소 수 - " << v.size() << endl;
	cout << " 벡터의 용량 - " << v.capacity() << endl;

	save("소스.cpp");

}파일 정보 : 소스.cpp, 크기:1285
2022-04-06 12:52:04 GMT+9
 저장 시간 : 2022-04-06 12:52:04 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>
#include<thread>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{
	save("소스.cpp");
	vector v{ 1,2,3 };

	//[문제 ]  vector의 메모리가 확장되는 모습을 관찰하고 싶다.
	// - 원소를 하나씩 추가 하면서 벡터가 관리하는 메모리의 크기를 관찰 
	// - vector의 masize?   X 용량 capacity
	// 원소를 추가하며 관찰
	size_t oldCap{ v.capacity() };

	while (true) {
		v.push_back(4);

		if (v.size() - 1 == oldCap) {
			cout << " 현재 원소 수 - " << v.size() << endl;
			cout << " 벡터의 용량 - " << v.capacity() << endl;
			oldCap = v.capacity();
			cout << endl;
		}

	}

}파일 정보 : 소스.cpp, 크기:1086
2022-04-06 12:56:55 GMT+9
 저장 시간 : 2022-04-06 12:56:55 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>
#include<thread>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{

	//[문제] 키보드에서 int를 입력받아
	// 합계와 평균을 출력하라.
	
	vector<int> v;

	int count{};
	int average{};
	int num{};
	int sum{};
	while (cin >> num) {
		count++;
		v.push_back(num);
		sum += num;
	}
	average = sum / count;
	cout << sum<<" - " << average << endl;


	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:1086
2022-04-06 12:57:21 GMT+9
 저장 시간 : 2022-04-06 12:57:21 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>
#include<thread>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{

	//[문제] 키보드에서 int를 입력받아
	// 합계와 평균을 출력하라.
	
	vector<int> v;

	int count{};
	int average{};
	int num{};
	int sum{};
	while (cin >> num) {
		count++;
		v.push_back(num);
		sum += num;
	}
	average = sum / count;
	cout << sum<<" - " << average << endl;


	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:1104
2022-04-06 12:58:16 GMT+9
 저장 시간 : 2022-04-06 12:58:16 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>
#include<thread>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{

	//[문제] 키보드에서 int를 입력받아
	// 합계와 평균을 출력하라.
	// -- 내가 푼답 ↓
	vector<int> v;

	int count{};
	int average{};
	int num{};
	int sum{};
	while (cin >> num) {
		count++;
		v.push_back(num);
		sum += num;
	}
	average = sum / count;
	cout << sum<<" - " << average << endl;


	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:1189
2022-04-06 13:02:10 GMT+9
 저장 시간 : 2022-04-06 13:02:10 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>
#include<thread>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{

	//[문제] 키보드에서 int를 입력받아
	// 합계와 평균을 출력하라.
	// -- 교수님 답 ↓
	vector<int> v;

	int num{};
	long long sum{};

	for (int n : v)																//&를 붙이는 이유 원본을 원격조작  데이터를 끌고올때 복사하지마라 라는이유. int를 생각해보면 비용차이가 없다. 
		sum += n;

	cout << "합계 - " << sum << endl;
	cout << "평균 - " << (double) sum / v. size() << endl;

	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:1241
2022-04-06 13:03:12 GMT+9
 저장 시간 : 2022-04-06 13:03:12 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>

#include<vector>
#include<thread>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool Check;

int main()
{

	//[문제] 키보드에서 int를 입력받아
	// 합계와 평균을 출력하라.
	// -- 교수님 답 ↓
	vector<int> v;

	int num{};
	long long sum{};

	while (cin >> num) {
		v.push_back(num);
	}


	for (int n : v)																//&를 붙이는 이유 원본을 원격조작  데이터를 끌고올때 복사하지마라 라는이유. int를 생각해보면 비용차이가 없다. 
		sum += n;

	cout << "합계 - " << sum << endl;
	cout << "평균 - " << (double) sum / v. size() << endl;

	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:842
2022-04-06 13:04:33 GMT+9
 저장 시간 : 2022-04-06 13:04:33 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v{ "진짜 벡터를 알아본다. "};

	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:875
2022-04-06 13:12:20 GMT+9
 저장 시간 : 2022-04-06 13:12:20 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v{ "진짜 벡터를 알아본다. "};
	
	v.push_back("STRING 추가");

	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:878
2022-04-06 13:16:26 GMT+9
 저장 시간 : 2022-04-06 13:16:26 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v{ "진짜 벡터를 알아본다. "};
	
	v.emplace_back("STRING 추가");

	save("소스.cpp");
	
}파일 정보 : 소스.cpp, 크기:1214
2022-04-06 13:17:36 GMT+9
 저장 시간 : 2022-04-06 13:17:36 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v{ "진짜 벡터를 알아본다. "};	
														
	//v.push_back("STRING 추가");

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.파일 정보 : 소스.cpp, 크기:1215
2022-04-06 13:18:47 GMT+9
 저장 시간 : 2022-04-06 13:18:47 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v{ "진짜 벡터를 알아본다. "};	
														
	v.emplace_back("STRING 추가");

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.파일 정보 : 소스.cpp, 크기:1215
2022-04-11 10:41:03 GMT+9
 저장 시간 : 2022-04-11 10:41:03 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (5주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v{ "진짜 벡터를 알아본다. "};	
														
	v.emplace_back("STRING 추가");

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.파일 정보 : 소스.cpp, 크기:1375
2022-04-11 10:59:57 GMT+9
 저장 시간 : 2022-04-11 10:59:57 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	

	vector<STRING> v{ "진짜 벡터를 알아본다. "};	
														
	v.emplace_back("STRING 추가"); // 인자만 넘긴다   v.empace_back((STRING)"STRING 추가")) 이런짓 X

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1279
2022-04-11 11:10:22 GMT+9
 저장 시간 : 2022-04-11 11:10:22 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v;	

	v.push_back("333");
	v.emplace_back("55555");

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1317
2022-04-11 11:24:28 GMT+9
 저장 시간 : 2022-04-11 11:24:28 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v;	

	v.push_back("333");
	v.emplace_back("55555");

	//트랜잭션 안전성(?) 때문에 
	//

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1333
2022-04-11 11:25:04 GMT+9
 저장 시간 : 2022-04-11 11:25:04 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                         (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v;	

	v.reserve(2);

	v.push_back("333");
	v.emplace_back("55555");

	//트랜잭션 안전성(?) 때문에 
	

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1442
2022-04-11 11:26:36 GMT+9
 저장 시간 : 2022-04-11 11:26:36 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                         (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	Check = true;

	vector<STRING> v;	

	v.reserve(2);		
	//내가 사용해야할 메모리를 짐작할수 있을때 미리 메모리를 확보해주면 메모리낭비가 줄고 속도 증가 배열처럼

	v.push_back("333");
	v.emplace_back("55555");

	//트랜잭션 안전성(?) 때문에 
	

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1470
2022-04-11 11:29:47 GMT+9
 저장 시간 : 2022-04-11 11:29:47 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{
	//Check = true;

	vector<STRING> v{ "1","333","55555","22","4444" };

	// [문제] 길이 오름차순 정렬 후 출력

	sort(v.begin(), v.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});

	for (const STRING& s : v)
		cout << s << endl;


	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1483
2022-04-11 11:30:20 GMT+9
 저장 시간 : 2022-04-11 11:30:20 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                         (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	vector<STRING> v{ "1","333","55555","22","4444" };

	// [문제] 길이 오름차순 정렬 후 출력

	Check = true;
	sort(v.begin(), v.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});
	Check = false;
	for (const STRING& s : v)
		cout << s << endl;


	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1483
2022-04-11 11:31:33 GMT+9
 저장 시간 : 2022-04-11 11:31:33 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                         (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	vector<STRING> v{ "1","333","55555","22","4444" };

	// [문제] 길이 오름차순 정렬 후 출력

	Check = true;
	sort(v.begin(), v.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});
	Check = false;
	for (const STRING& s : v)
		cout << s << endl;


	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1629
2022-04-11 11:50:28 GMT+9
 저장 시간 : 2022-04-11 11:50:28 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	// [ 문제 ] 짝수를 제거하고 출력하라. 
	for (int i = 0; i < v.size(); ++i) {
		if (v[i] % 2 == 0) {
			v.erase(v.begin() + i);
		}
	}
	
	for (int n : v)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1711
2022-04-11 11:53:56 GMT+9
 저장 시간 : 2022-04-11 11:53:56 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	// [ 문제 ] 짝수를 제거하고 출력하라.
	//for (int i = 0; i < v.size(); ++i) {
	//	if (v[i] % 2 == 0) {
	//		v.erase(v.begin() + i);
	//	}
	//}
	remove_if(v.begin(), v.end(), [](int n) {
		return n % 2 == 0;
		});
	
	for (int n : v)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1595
2022-04-11 12:03:54 GMT+9
 저장 시간 : 2022-04-11 12:03:54 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	auto	p = remove_if(v.begin(), v.end(), [](int n) {
		return n % 2 == 0;
		});
		// 시작 번지수를 알려준다
	
	v.erase(p, v.end());

	for (int n : v)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1717
2022-04-11 12:06:50 GMT+9
 저장 시간 : 2022-04-11 12:06:50 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	auto	p = remove_if(v.begin(), v.end(), [](int n) {
		return n % 2 == 0;
		});  // 새  마지막 위치를 알려준다. 그 위치를 vector의 시작으로받음
	//	 iterator (반복자) 고도로 추상화 시켜준 디자인 패턴,
	
	v.erase(p, v.end());

	for (int n : v)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1803
2022-04-13 11:38:39 GMT+9
 저장 시간 : 2022-04-13 11:38:39 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<array>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	// [문제] "소스.cpp"를 읽어 알파벳의 개수를 다음과 같이 출력하라
	// 대소문자를 구분하진 않는다. 
	// [a] - 10
	// [b] - 2
	// .... 
	// [z] - 1
	ifstream in("소스.cpp");
	array<int, 26> arr{};
	char ch;
	while (in >> ch)
	{
		if (isalpha(ch))
			arr[tolower(ch) - 'a']++;
	}
	for (int i = 0; i < arr.size(); ++i)
		cout << "[" << static_cast<char>('a' + i) << "]  - " << endl;
	
	

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1813
2022-04-13 11:39:07 GMT+9
 저장 시간 : 2022-04-13 11:39:07 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<array>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	// [문제] "소스.cpp"를 읽어 알파벳의 개수를 다음과 같이 출력하라
	// 대소문자를 구분하진 않는다. 
	// [a] - 10
	// [b] - 2
	// .... 
	// [z] - 1
	ifstream in("소스.cpp");
	array<int, 26> arr{};
	char ch;
	while (in >> ch)
	{
		if (isalpha(ch))
			arr[tolower(ch) - 'a']++;
	}
	for (int i = 0; i < arr.size(); ++i)
		cout << "[" << static_cast<char>('a' + i) << "]  - " << arr[i] << endl;
	
	

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1800
2022-04-13 11:39:25 GMT+9
 저장 시간 : 2022-04-13 11:39:25 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<array>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	// [문제] "소스.cpp"를 읽어 알파벳의 개수를 다음과 같이 출력하라
	// 대소문자를 구분하진 않는다. 
	// [a] - 10
	// [b] - 2
	// .... 
	// [z] - 1
	ifstream in("소스.cpp");
	array<int, 26> arr{};
	char ch;
	while (in >> ch)
	{
		if (isalpha(ch))
			arr[tolower(ch) - 'a']++;
	}
	for (int i = 0; i < arr.size(); ++i)
		cout << "[" << char('a' + i) << "]  - " << arr[i] << endl;
	
	

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1777
2022-04-13 11:40:22 GMT+9
 저장 시간 : 2022-04-13 11:40:22 GMT+9

//-----------------------------------------------------------------------------
//2022.4.6  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<array>
#include<string>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;



int main()
{

	// [문제] "소스.cpp"를 읽어 알파벳의 개수를 다음과 같이 출력하라
	// 대소문자를 구분하진 않는다. 
	// [a] - 10
	// [b] - 2
	// .... 
	// [z] - 1
	
	array<int, 26> arr{};
	char ch;
	while (cin >> ch)
	{
		if (isalpha(ch))
			arr[tolower(ch) - 'a']++;
	}
	for (int i = 0; i < arr.size(); ++i)
		cout << "[" << char('a' + i) << "]  - " << arr[i] << endl;
	
	

	save("소스.cpp");
	
}
//1. push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
//2. 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
//3. 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
//4. 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던(1번) item 임시 객체를 소멸시킵니다.

// 생성자는 메모리를 생성하는 것이 아닌 생성된 메모리를 활용하는ㄴ내용
// 소멸자도
파일 정보 : 소스.cpp, 크기:1122
2022-04-13 11:44:38 GMT+9
 저장 시간 : 2022-04-13 11:44:38 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;


//[문제]  세번째 원소 STRING("33333")을 끼워넣고 전체를 출력하라
int main()
{
	vector<STRING> v{ "1","22","333","444","55555" };
	v.insert(v.begin()+2,"333333");
	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1168
2022-04-13 11:45:33 GMT+9
 저장 시간 : 2022-04-13 11:45:33 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;


//[문제]  세번째 원소 STRING("33333")을 끼워넣고 전체를 출력하라
int main()
{
	vector<STRING> v{ "1","22","333","444","55555" };
	v.insert(v.begin()+2,"333333");
	
	for (STRING n : v)
		cout << n << endl;
	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1191
2022-04-13 11:49:18 GMT+9
 저장 시간 : 2022-04-13 11:49:18 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;


//[문제]  세번째 원소 STRING("33333")을 끼워넣고 전체를 출력하라
// 내가 푼 답 
int main()
{
	Check = true;
	vector<STRING> v{ "1","22","333","444","55555" };
	v.insert(v.begin()+2,"333333");
	
	for (const STRING& n : v)
		cout << n << endl;
	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1218
2022-04-13 11:52:48 GMT+9
 저장 시간 : 2022-04-13 11:52:48 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;


//[문제]  세번째 원소 STRING("33333")을 끼워넣고 전체를 출력하라
int main()
{
	Check = true;
	vector<STRING> v{ "1","22","333","444","55555" };
	auto p = v.cbegin();
	++p;
	++p;
	v.insert(p,"333333");
	
	for (const STRING& n : v)
		cout << n << endl;
	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1227
2022-04-13 11:53:35 GMT+9
 저장 시간 : 2022-04-13 11:53:35 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;


//[문제]  세번째 원소 STRING("33333")을 끼워넣고 전체를 출력하라
int main()
{
	Check = true;
	vector<STRING> v{ "1","22","333","444","55555" };
	auto p = v.cbegin();
	++p;
	++p;
	v.insert(p,"333");
	
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;
	save("소스.cpp");
	
}

파일 정보 : 소스.cpp, 크기:1221
2022-04-13 11:55:43 GMT+9
 저장 시간 : 2022-04-13 11:55:43 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
// 
// STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너 / 알고리즘에서 사용
// 
// 클래스의 맴버 변수를 private이 아니라면 ?
// 
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<vector>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;


//[문제]  세번째 원소 STRING("33333")을 끼워넣고 전체를 출력하라
int main()
{
	vector<STRING> v{ "1","22","333","444","55555" };
	
	Check = true;
	v.insert(v.begin() += 2 ,"333");
	Check = false;
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;
	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:992
2022-04-13 12:15:06 GMT+9
 저장 시간 : 2022-04-13 12:15:06 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

int main()
{
	deque<STRING> d{ "1","22","333","4444","55555" };
	
	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << endl;
	}
	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1023
2022-04-13 12:16:40 GMT+9
 저장 시간 : 2022-04-13 12:16:40 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

int main()
{
	deque<STRING> d{ "1","22","333","4444","55555" };
	
	cout << sizeof(d) << endl;

	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << endl;
	}
	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1118
2022-04-13 12:17:15 GMT+9
 저장 시간 : 2022-04-13 12:17:15 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

int main()
{
	deque<STRING> d{ "1","22","333","4444","55555" };
	vector<STRING> v{ "1","22","333","4444","55555" };

	cout << sizeof(d) << endl;
	cout << sizeof(v) << endl;
	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << endl;
	}
	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1067
2022-04-13 12:31:25 GMT+9
 저장 시간 : 2022-04-13 12:31:25 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

int main()
{
	deque<STRING> d{ "1","22","333","4444","55555" };
	
	cout << "덱의 메모리 크기 - " << sizeof(d) << endl;
	

	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << endl;
	}
	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1034
2022-04-13 12:31:52 GMT+9
 저장 시간 : 2022-04-13 12:31:52 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

int main()
{
	deque<STRING> d{ "1","22","333","4444","55555" };
	
	d.push_front("-333");

	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << endl;
	}
	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1122
2022-04-13 12:35:38 GMT+9
 저장 시간 : 2022-04-13 12:35:38 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	char c[1024];

public:
	void show() const {
		cout << this << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	vector<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1122
2022-04-13 12:36:30 GMT+9
 저장 시간 : 2022-04-13 12:36:30 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	char c[1000];

public:
	void show() const {
		cout << this << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	vector<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1127
2022-04-13 12:36:55 GMT+9
 저장 시간 : 2022-04-13 12:36:55 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	char c[1000];

public:
	void show() const {
		cout << int(this) << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	vector<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1126
2022-04-13 12:37:47 GMT+9
 저장 시간 : 2022-04-13 12:37:47 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	char c[1000];

public:
	void show() const {
		cout << int(this) << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	deque<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1121
2022-04-13 12:38:37 GMT+9
 저장 시간 : 2022-04-13 12:38:37 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	char c[1000];

public:
	void show() const {
		cout << this << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	deque<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1121
2022-04-13 12:38:47 GMT+9
 저장 시간 : 2022-04-13 12:38:47 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	char c[1024];

public:
	void show() const {
		cout << this << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	deque<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1114
2022-04-13 12:39:57 GMT+9
 저장 시간 : 2022-04-13 12:39:57 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	int n;

public:
	void show() const {
		cout << this << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	deque<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1140
2022-04-13 12:42:38 GMT+9
 저장 시간 : 2022-04-13 12:42:38 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

class Test {
	int n;

public:
	void show() const {
		cout << this << endl;
	}
};

int main()
{
	// [확인] vector와 deque 메모리 연속성 
	deque<Test> v(10);

	v.push_front(Test{});

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");	
}
파일 정보 : 소스.cpp, 크기:1050
2022-04-13 12:48:59 GMT+9
 저장 시간 : 2022-04-13 12:48:59 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;


int main()
{
	save("소스.cpp");	
	// [확인] deque이 vector 보다 원소를 더 많이 저장할 수 있다고? 
	vector<int> v;
	
	while (true)
		v.push_back(1);

}
파일 정보 : 소스.cpp, 크기:1174
2022-04-13 12:51:46 GMT+9
 저장 시간 : 2022-04-13 12:51:46 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;


int main()
{
	save("소스.cpp");	
	// [확인] deque이 vector 보다 원소를 더 많이 저장할 수 있다고? 
	vector<int> v;
	
	while (true) {
		try {
			v.push_back(1);
		}
		catch (exception& e) {
			cout << " 현재 v의 원소 갯수 - " << v.size() << endl;
			return 0;
		}
	}

}
파일 정보 : 소스.cpp, 크기:1174
2022-04-13 12:53:58 GMT+9
 저장 시간 : 2022-04-13 12:53:58 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;


int main()
{
	save("소스.cpp");	
	// [확인] deque이 vector 보다 원소를 더 많이 저장할 수 있다고? 
	vector<int> v;
	
	while (true) {
		try {
			v.push_back(1);
		}
		catch (exception& e) {
			cout << " 현재 v의 원소 갯수 - " << v.size() << endl;
			return 0;
		}
	}

}
파일 정보 : 소스.cpp, 크기:1196
2022-04-13 12:55:14 GMT+9
 저장 시간 : 2022-04-13 12:55:14 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;


int main()
{
	save("소스.cpp");	
	// [확인] deque이 vector 보다 원소를 더 많이 저장할 수 있다고? 
	// vector -136216567
	deque<int> v;
	
	while (true) {
		try {
			v.push_back(1);
		}
		catch (exception& e) {
			cout << " 현재 v의 원소 갯수 - " << v.size() << endl;
			return 0;
		}
	}

}
파일 정보 : 소스.cpp, 크기:1396
2022-04-13 12:58:50 GMT+9
 저장 시간 : 2022-04-13 12:58:50 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;


int main()
{
	save("소스.cpp");
	// [확인] deque이 vector 보다 원소를 더 많이 저장할 수 있다고? 
	// vector -    136216567
	// deque -  268435452
	vector<int> v;

	while (true) {
		try {
			v.push_back(1);
		}
		catch (exception& e) {
			cout << " 현재 v의 원소 갯수 - " << v.size() << endl;
			break;
		}
	}


	deque<int> d;

	while (true) {
		try {
			d.push_back(1);
		}
		catch (exception& e) {
			cout << " 현재 v의 원소 갯수 - " << d.size() << endl;
			return 0;
		}
	}
}파일 정보 : 소스.cpp, 크기:1460
2022-04-13 13:09:18 GMT+9
 저장 시간 : 2022-04-13 13:09:18 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"
#include<vector>
using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	string str;
	deque<string> dq;
	while (in >> str) {
		dq.push_back(str);
	}
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << " ";
	}
	sort(dq.begin(), dq.end());

	cout << endl;
	cout << endl;
	
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << " ";
	}

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1447
2022-04-13 13:14:36 GMT+9
 저장 시간 : 2022-04-13 13:14:36 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	string str;
	deque<string> dq;
	while (in >> str) {
		dq.push_front(str);
	}
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << '\t';
	}
	sort(dq.begin(), dq.end());

	cout << endl;
	cout << endl;
	
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << '\t';
	}

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1524
2022-04-13 13:17:25 GMT+9
 저장 시간 : 2022-04-13 13:17:25 GMT+9

//-----------------------------------------------------------------------------
//2022.4.13  수 34                    월23수34                          (6주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	string str;
	deque<string> dq;
	while (in >> str) {
		dq.push_front(str);
	}
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << '\t';
	}
	sort(dq.begin(), dq.end(), [](const string& a, const string& b) {
		return a.size() < b.size(); });

	cout << endl;
	cout << endl;
	
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << endl;
	}

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1797
2022-04-18 10:41:54 GMT+9
 저장 시간 : 2022-04-18 10:41:54 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	string str;
	deque<string> dq;
	while (in >> str) {
		dq.push_front(str);
	}
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << '\t';
	}
	sort(dq.begin(), dq.end(), [](const string& a, const string& b) {
		return a.size() < b.size(); });

	cout << endl;
	cout << endl;
	
	for (int i = 0; i < dq.size(); ++i) {
		cout << dq[i] << endl;
	}

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1498
2022-04-18 10:43:40 GMT+9
 저장 시간 : 2022-04-18 10:43:40 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };

	string str;

	in >> str;
	cout << str;

	cout << endl;

	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1534
2022-04-18 10:44:15 GMT+9
 저장 시간 : 2022-04-18 10:44:15 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };

	string str;
	for (int i = 0; i < 10; ++i) {
		in >> str;
		cout << str;

		cout << endl;
	}
	save("소스.cpp");
}파일 정보 : 소스.cpp, 크기:1551
2022-04-18 10:46:13 GMT+9
 저장 시간 : 2022-04-18 10:46:13 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };

	string str;
	for (int i = 0; ; ++i) {
		if (!(in >> str))
			break;

		cout << str;
		cout << endl;
	}
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1687
2022-04-18 10:53:52 GMT+9
 저장 시간 : 2022-04-18 10:53:52 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };

	deque<string> d;
	string str;

	while (in >> str)
		d.push_back(str);

	cout << " 모두  " << d.size() << " 단어를 읽었다." << endl;
	
	cout << boolalpha<<(string{ "가나다" } < string{ "라" }) << endl;



	//sort(d.begin(), d.end());


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1689
2022-04-18 10:54:09 GMT+9
 저장 시간 : 2022-04-18 10:54:09 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };

	deque<string> d;
	string str;

	while (in >> str)
		d.push_back(str);

	cout << " 모두  " << d.size() << " 단어를 읽었다." << endl;
	
	cout << boolalpha<<(string{ "마가나다" } < string{ "라" }) << endl;



	//sort(d.begin(), d.end());


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1660
2022-04-18 10:54:49 GMT+9
 저장 시간 : 2022-04-18 10:54:49 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };

	deque<string> d;
	string str;

	while (in >> str)
		d.push_back(str);

	cout << " 모두  " << d.size() << " 단어를 읽었다." << endl;
	
	for (string s : d)
		cout << s << endl;


	//sort(d.begin(), d.end());


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1661
2022-04-18 10:55:14 GMT+9
 저장 시간 : 2022-04-18 10:55:14 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };

	deque<string> d;
	string str;

	while (in >> str)
		d.push_back(str);

	cout << " 모두  " << d.size() << " 단어를 읽었다." << endl;
	
	sort(d.begin(), d.end());
	
	for (string s : d)
		cout << s << endl;




	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1649
2022-04-18 11:05:39 GMT+9
 저장 시간 : 2022-04-18 11:05:39 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	deque<string> d{istream_iterator<string>{in}, {}};

	sort(d.begin(), d.end(), [](const string& a, const string& b) {
		return a > b;
		});

	copy(d.begin(), d.end(), ostream_iterator<string>{cout, "\n"});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1649
2022-04-18 11:09:25 GMT+9
 저장 시간 : 2022-04-18 11:09:25 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "연습.txt" };
	deque<string> d{istream_iterator<string>{in}, {}};

	sort(d.begin(), d.end(), [](const string& a, const string& b) {
		return a > b;
		});

	copy(d.begin(), d.end(), ostream_iterator<string>{cout, "\n"});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1720
2022-04-18 11:11:54 GMT+9
 저장 시간 : 2022-04-18 11:11:54 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "연습.txt" };
	deque<char> d{istream_iterator<char>{in}, {}};

	sort(d.begin(), d.end(), [](const char&a, const char& b) {
		return a > b;
		});

	copy(d.begin(), d.end(), ostream_iterator<char>{cout, "\n"});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1892
2022-04-18 11:14:35 GMT+9
 저장 시간 : 2022-04-18 11:14:35 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라
// 각 단어를 오름차순으로 정렬하라
// 정렬된 결과를 출력하라.

int main()
{
	ifstream in{ "연습.txt" };
	deque<string> d{istream_iterator<string>{in}, {}};

	sort(d.begin(), d.end(), [](const string& a, const string& b) {
		return a > b;
		});

	// 각 단어를 오름차순(ascending order) 정렬
	
	for (int i = 0; i < d.size(); ++i) {
		sort(d[i].begin(), d[i].end());
	}

	copy(d.begin(), d.end(), ostream_iterator<string>{cout, "\n"});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1693
2022-04-18 11:20:38 GMT+9
 저장 시간 : 2022-04-18 11:20:38 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
//

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	deque<string> d;

	while (in >> str)
		d.push_back(str);

	//[문제] common은 몇번 단어인지 찾아라
	// 있다면 출력하라.

	auto a = find(d.begin(), d.end(), "common");
	cout << typeid(a).name() << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1651
2022-04-18 11:21:25 GMT+9
 저장 시간 : 2022-04-18 11:21:25 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
//

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	deque<string> d;

	while (in >> str)
		d.push_back(str);

	//[문제] common은 몇번 단어인지 찾아라
	// 있다면 출력하라.

	find(d.begin(), d.end(), "common");
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1812
2022-04-18 11:37:58 GMT+9
 저장 시간 : 2022-04-18 11:37:58 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
//

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	deque<string> d;

	while (in >> str)
		d.push_back(str);

	//[문제] common은 몇번 단어인지 찾아라
	// 있다면 출력하라.

	auto p = find(d.begin(), d.end(), string{ "common" });
	
	if (p == d.end()) {
		cout << "없는 단어 입니다." << endl;
	}
	else {
		cout << p - d.begin() + 1 << " 번째 단어입니다." << endl;
	}

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1815
2022-04-18 11:38:26 GMT+9
 저장 시간 : 2022-04-18 11:38:26 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
//

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	deque<string> d;

	while (in >> str)
		d.push_back(str);

	//[문제] common은 몇번 단어인지 찾아라
	// 있다면 출력하라.

	auto p = find(d.begin(), d.end(), string{ "container" });
	
	if (p == d.end()) {
		cout << "없는 단어 입니다." << endl;
	}
	else {
		cout << p - d.begin() + 1 << " 번째 단어입니다." << endl;
	}

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1596
2022-04-18 11:40:46 GMT+9
 저장 시간 : 2022-04-18 11:40:46 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			s
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include<string>
#include<deque>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool Check;

//[문제] "소스.cpp" 파일의 단어를 deque<string>에 저장하라.
//

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> d;

	cout << "리스트 - 크기" << sizeof(list<string>) << endl;


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1494
2022-04-18 11:47:11 GMT+9
 저장 시간 : 2022-04-18 11:47:11 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	for (const string&s : cont)
		cout << s << endl;


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1736
2022-04-18 11:56:18 GMT+9
 저장 시간 : 2022-04-18 11:56:18 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);
	//[ 문제 ] common는 몇 번째 단어인지 출력하라.

	auto p = find(cont.begin(), cont.end(), "common");
	
	int step{};
	auto beg = cont.begin();

	while (true) {
		if (beg == p) {
			break;
		}
		else {
			++beg;
			++step;
		}
	}
	cout << step + 1<<" 번째 단어입니다. " << endl;



	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1621
2022-04-18 11:57:23 GMT+9
 저장 시간 : 2022-04-18 11:57:23 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);
	//[ 문제 ] common는 몇 번째 단어인지 출력하라.

	auto p = find(cont.begin(), cont.end(), "common");
	


	cout <<distance(cont.begin(),p)+1 <<" 번째 단어입니다. " << endl;



	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1684
2022-04-18 11:59:38 GMT+9
 저장 시간 : 2022-04-18 11:59:38 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();

	//[ 문제 ] common는 몇 번째 단어인지 출력하라.

	auto p = find(cont.begin(), cont.end(), "common");
	
	cout <<distance(cont.begin(),p)+1 <<" 번째 단어입니다. " << endl;

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1678
2022-04-18 12:03:35 GMT+9
 저장 시간 : 2022-04-18 12:03:35 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	//[ 문제 ] common는 몇 번째 단어인지 출력하라.

	auto p = find(cont.begin(), cont.end(), "As");
	
	cout <<distance(cont.begin(),p)+1 <<" 번째 단어입니다. " << endl;

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1678
2022-04-18 12:03:53 GMT+9
 저장 시간 : 2022-04-18 12:03:53 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	//[ 문제 ] common는 몇 번째 단어인지 출력하라.

	auto p = find(cont.begin(), cont.end(), "an");
	
	cout <<distance(cont.begin(),p)+1 <<" 번째 단어입니다. " << endl;

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1677
2022-04-18 12:04:07 GMT+9
 저장 시간 : 2022-04-18 12:04:07 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	//[ 문제 ] common는 몇 번째 단어인지 출력하라.

	auto p = find(cont.begin(), cont.end(), "a");
	
	cout <<distance(cont.begin(),p)+1 <<" 번째 단어입니다. " << endl;

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1715
2022-04-18 12:10:50 GMT+9
 저장 시간 : 2022-04-18 12:10:50 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	
	//[ 문제 ] 앞에서 부터 10개만 출력하라. 
	auto p{ cont.begin() };
	for (int i{}; i < 10; ++i) {
		cout << *p << endl; // 역참조
	}
	cout <<distance(cont.begin(),p)+1 <<" 번째 단어입니다. " << endl;

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1719
2022-04-18 12:11:13 GMT+9
 저장 시간 : 2022-04-18 12:11:13 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	
	//[ 문제 ] 앞에서 부터 10개만 출력하라. 
	auto p{ cont.begin() };
	for (int i{}; i < 10; ++i) {

		cout << *p++ << endl; // 역참조
	}
	cout <<distance(cont.begin(),p)+1 <<" 번째 단어입니다. " << endl;

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1652
2022-04-18 12:12:01 GMT+9
 저장 시간 : 2022-04-18 12:12:01 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	
	//[ 문제 ] 뒤에서 부터 10개만 출력하라. 
	auto p{ cont.rbegin() };
	for (int i{}; i < 10; ++i) {

		cout << *p++ << endl; // 역참조
	}

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1654
2022-04-18 12:14:02 GMT+9
 저장 시간 : 2022-04-18 12:14:02 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	
	//[ 문제 ] 뒤에서 부터 10개만 출력하라. 
	auto p{ cont.rbegin() };

	for (int i{}; i < 10; ++i) {

		cout << *p++ << endl; // 역참조
	}

	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1688
2022-04-18 12:19:29 GMT+9
 저장 시간 : 2022-04-18 12:19:29 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	
	//[ 문제 ] 글자수가 5개인 것만 화면에 출력하라.

	copy_if(cont.begin(), cont.end(), std::ostream_iterator<string>{cout, "\n"}, [](const string& a) {
		return a.size() == 5; });
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1702
2022-04-18 12:20:32 GMT+9
 저장 시간 : 2022-04-18 12:20:32 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	
	//[ 문제 ] 글자수가 5개인 것의 갯수를 화면에 출력하라. 

	int num = count_if(cont.begin(), cont.end(),[](const string& a) {
		return a.size() == 5; });
	
	cout << "5 글자 단어 수 : " << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1707
2022-04-18 12:20:43 GMT+9
 저장 시간 : 2022-04-18 12:20:43 GMT+9

//-----------------------------------------------------------------------------
//2022.4.18  월 23                    월23수34                          (7주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[],array<T,N>, vector<T>, string<char>
// 
// Sequence Container	- 원소의 순서를 임의 지정가능 
//				- array		유일하게 크기가 컴파일 타임에 결정되어야
//				- vector	dynamic array (실행 시간에 크기가 바뀌는 배열)
//				반복자 무효화 * 
//				- deque	double ended queue 벡터와 리스트의 중간단계  contiguous가 아니다. 
//								벡터보다 더 많은 원소를 저장할 수 있다. 
//								반복자가 무효화되지 않는다. 			
//				- list			
// 
// 
//	Associative Container
// Unordered Associative Container
//				-  중간고사 시험 예정 4/20(수) (7주 2일)
// 
//  list 알아오기, 책의 예제 풀어보기,
// sequence container까지 시험범위 , 
// 그림공부 정확하게 이해가 되야되고
// 시험문제는 deque<Dog>.. 클래스를 만들어놓고 컨테이너에 내가만든 객체를 집어넣기
//-----------------------------------------------------------------------------

#include<iostream>
#include<list>
#include<fstream>
#include<algorithm>
#include "save.h"

using namespace std;

int main()
{
	ifstream in{ "연습.txt" };
	
	string str;
	list<string> cont;

	while (in >> str)
		cont.push_back(str);

	//[ 문제] cont를 ascending order로 정렬하라.
	cont.sort();
	
	//[ 문제 ] 글자수가 5개인 것의 갯수를 화면에 출력하라. 

	int num = count_if(cont.begin(), cont.end(),[](const string& a) {
		return a.size() == 5; });
	
	cout << "5 글자 단어 수 : " <<num<< endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:893
2022-04-25 11:52:48 GMT+9
 저장 시간 : 2022-04-25 11:52:48 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
// 
// forward_list -  
// It is intended that forward_list have zero space or time overhead
// relative to a hand-written C-style singly linked list.	
// Features that would conflict with that goal have been omitted.
//	어떤 컨테이너간에 충돌하는 것은  아예 존재하지 않는다. 
//				반복자 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main()
{
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1061
2022-04-25 12:04:07 GMT+9
 저장 시간 : 2022-04-25 12:04:07 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main()
{
	char c = 'A';

	char* p = &c; // 얘가지고 뭘 할수 있을까? 
	//랜덤억세스가 가능한 . 메모리가 어디에 있더라도 순식간에 쫓아갈수 있다.
	//일반화를 한다면
	*p;
	++p;
	p == p;

	p += 100;  // 포인터는 메모리를 찍는 놈

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1010
2022-04-25 12:06:12 GMT+9
 저장 시간 : 2022-04-25 12:06:12 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main()
{
	// 모니터 화면을 가리키는 포인터를 추상화한 반복자 
	ostream_iterator<char> p{ cout };			//p는 모니터 좌 상단에 위치

	*p = 'A';
	++p;
	*p = 'B';
	++p;
	*p = 'C';


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1010
2022-04-25 12:06:26 GMT+9
 저장 시간 : 2022-04-25 12:06:26 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main()
{
	// 모니터 화면을 가리키는 포인터를 추상화한 반복자 
	ostream_iterator<char> p{ cout };			//p는 모니터 좌 상단에 위치

	*p = 'A';
	++p;
	*p = 'B';
	++p;
	*p = 'C';


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:993
2022-04-25 12:10:38 GMT+9
 저장 시간 : 2022-04-25 12:10:38 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main()
{
	// 모니터 화면을 가리키는 포인터를 추상화한 반복자 
	ostream_iterator<char> p{ cout };			//p는 모니터 좌 상단에 위치

	p = 'A';
	p = 'B';
	p = 'C';


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1043
2022-04-25 12:12:15 GMT+9
 저장 시간 : 2022-04-25 12:12:15 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

int main()
{
	// 모니터 화면을 가리키는 포인터를 추상화한 반복자 
	ostream_iterator<char> p{ cout };			//p는 모니터 좌 상단에 위치

	*p = 'A';				//역방향 반복자 코딩한 후 이해될 거임
	++p; 
	p = 'B';
	p = 'C';


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1187
2022-04-25 12:19:15 GMT+9
 저장 시간 : 2022-04-25 12:19:15 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함
// 나는 왜 여기 앉아 있을까 생각해 본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(Iter).name() << endl;
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	
	show(istream_iterator<char>{cin});
	show(ostream_iterator<char>{cout});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1195
2022-04-25 12:20:12 GMT+9
 저장 시간 : 2022-04-25 12:20:12 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함
// 나는 왜 여기 앉아 있을까 생각해 본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(Iter).name() << endl;
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	show(1);
	show(istream_iterator<char>{cin});
	show(ostream_iterator<char>{cout});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1279
2022-04-25 12:22:22 GMT+9
 저장 시간 : 2022-04-25 12:22:22 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함
// 나는 왜 여기 앉아 있을까 생각해 본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(Iter).name() << endl;
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	//의문 -> 템플릿 함수에는 뭐가 전달될지 모른다. 알았으면 더 좋은 코딩을 하겠는데?
	show(1);
	show(istream_iterator<char>{cin});
	show(ostream_iterator<char>{cout});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1279
2022-04-27 11:31:59 GMT+9
 저장 시간 : 2022-04-27 11:31:59 GMT+9

//-----------------------------------------------------------------------------
//2022.4.25  월 23                    월23수34                          (8주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers	
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 동일한 방식으로 접근하기위해
// 
//	Associative Container
// Unordered Associative Container
// 
//  6/6일(월요일) - 수업을 해야 함
// 나는 왜 여기 앉아 있을까 생각해 본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(Iter).name() << endl;
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	//의문 -> 템플릿 함수에는 뭐가 전달될지 모른다. 알았으면 더 좋은 코딩을 하겠는데?
	show(1);
	show(istream_iterator<char>{cin});
	show(ostream_iterator<char>{cout});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1442
2022-04-27 11:42:35 GMT+9
 저장 시간 : 2022-04-27 11:42:35 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
	
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	//의문 -> 템플릿 함수에는 뭐가 전달될지 모른다. 알았으면 더 좋은 코딩을 하겠는데?

	int* p{};

	show(p);
	show(istream_iterator<char>{cin});
	show(ostream_iterator<char>{cout});

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1709
2022-04-27 11:47:28 GMT+9
 저장 시간 : 2022-04-27 11:47:28 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
	
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	//의문 -> 템플릿 함수에는 뭐가 전달될지 모른다. 알았으면 더 좋은 코딩을 하겠는데?

	int* p{};

	show(p);								// 모든 T*는 랜덤억세스 반복자로 등록되어 있다.
	show(istream_iterator<char>{cin});
	show(ostream_iterator<char>{cout});
	show(forward_list<char>::iterator());
	show(list<char>{}.begin());
	show(deque<char>::iterator());
	show(vector<char>::iterator());

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1749
2022-04-27 11:50:29 GMT+9
 저장 시간 : 2022-04-27 11:50:29 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
	
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	//의문 -> 템플릿 함수에는 뭐가 전달될지 모른다. 알았으면 더 좋은 코딩을 하겠는데?
	//show(1);	//반복자로 등록된 놈이아님
	int* p{};

	show(p);								// 모든 T*는 랜덤억세스 반복자로 등록되어 있다.
	show(istream_iterator<char>{cin});
	show(ostream_iterator<char>{cout});
	show(forward_list<char>::iterator());
	show(list<char>{}.begin());
	show(deque<char>::iterator());
	show(vector<char>::iterator());


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1479
2022-04-27 11:51:15 GMT+9
 저장 시간 : 2022-04-27 11:51:15 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
#include<array>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
	
}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	
	//의문 -> 템플릿 함수에는 뭐가 전달될지 모른다. 알았으면 더 좋은 코딩을 하겠는데?
	
	array<int, 3> a;
	show(a.begin());
	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1463
2022-04-27 11:54:53 GMT+9
 저장 시간 : 2022-04-27 11:54:53 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
#include<array>
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	//반복자 종류를 출력해 본다. show(): 반복자 종류를 출력한다. 
	
	//의문 -> 템플릿 함수에는 뭐가 전달될지 모른다. 알았으면 더 좋은 코딩을 하겠는데?
	
	array<int, 3> a;
	show(a.begin());
	

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1279
2022-04-27 12:04:33 GMT+9
 저장 시간 : 2022-04-27 12:04:33 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };

	for (char c : str)
		cout << c << " ";
	cout << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1308
2022-04-27 12:05:03 GMT+9
 저장 시간 : 2022-04-27 12:05:03 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hellozzzzzzzxxxxxxxxxxxxxssssssscc" };

	for (char c : str)
		cout << c << " ";
	cout << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1312
2022-04-27 12:05:58 GMT+9
 저장 시간 : 2022-04-27 12:05:58 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	
	for (auto i = str.begin(); i != str.end(); ++i)
		cout << *i << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1383
2022-04-27 12:07:19 GMT+9
 저장 시간 : 2022-04-27 12:07:19 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	string str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	for (auto i = str.rbegin(); i != str.rend(); ++i)
		cout << *i << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1423
2022-04-27 12:15:04 GMT+9
 저장 시간 : 2022-04-27 12:15:04 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//for (auto i = str.rbegin(); i != str.rend(); ++i)
	//	cout << *i << " ";
	//cout << endl;

	cout << str.rbegin() << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1427
2022-04-27 12:15:22 GMT+9
 저장 시간 : 2022-04-27 12:15:22 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//for (auto i = str.rbegin(); i != str.rend(); ++i)
	//	cout << *i << " ";
	//cout << endl;

	cout << str.rbegin() - 1 << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1420
2022-04-27 12:15:42 GMT+9
 저장 시간 : 2022-04-27 12:15:42 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//for (auto i = str.rbegin(); i != str.rend(); ++i)
	//	cout << *i << " ";
	//cout << endl;

	cout << str.end() << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1387
2022-04-27 12:32:42 GMT+9
 저장 시간 : 2022-04-27 12:32:42 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	for (auto i = str.rbegin() - 1; i != str.rend(); --i)
		cout << *i << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1391
2022-04-27 12:33:17 GMT+9
 저장 시간 : 2022-04-27 12:33:17 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	for (auto i = str.rbegin() - 1; i != str.rend() - 1; --i)
		cout << *i << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1448
2022-04-27 12:49:33 GMT+9
 저장 시간 : 2022-04-27 12:49:33 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//sort(str.begin(), str.end()); STRING이 sort가 되게 하자

	for (auto i = str.rbegin() ; i != str.rend() ; ++i)
		cout << *i << " ";
	cout << endl;
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1448
2022-04-27 12:51:14 GMT+9
 저장 시간 : 2022-04-27 12:51:14 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//sort(str.begin(), str.end()); STRING이 sort가 되게 하자

	for (auto i = str.rbegin() ; i != str.rend() ; ++i)
		cout << *i << " ";
	cout << endl;
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1448
2022-04-27 12:56:17 GMT+9
 저장 시간 : 2022-04-27 12:56:17 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//sort(str.begin(), str.end()); STRING이 sort가 되게 하자

	for (auto i = str.rbegin() ; i != str.rend() ; ++i)
		cout << *i << " ";
	cout << endl;
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1448
2022-04-27 12:57:30 GMT+9
 저장 시간 : 2022-04-27 12:57:30 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//sort(str.begin(), str.end()); STRING이 sort가 되게 하자

	for (auto i = str.rbegin() ; i != str.rend() ; ++i)
		cout << *i << " ";
	cout << endl;
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1463
2022-04-27 13:00:32 GMT+9
 저장 시간 : 2022-04-27 13:00:32 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello123456789876543" };
	//역방향 반복자를 만들어 다음 코드가 실행되게 하라.
	//sort(str.begin(), str.end()); STRING이 sort가 되게 하자

	for (auto i = str.rbegin() ; i != str.rend() ; ++i)
		cout << *i << " ";
	cout << endl;
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1433
2022-04-27 13:03:11 GMT+9
 저장 시간 : 2022-04-27 13:03:11 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	// [도전] str을 sort로 정렬할 수 있게 한다.
	
	sort(str.begin(), str.end());

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1458
2022-04-27 13:03:52 GMT+9
 저장 시간 : 2022-04-27 13:03:52 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	// [도전] str을 sort로 정렬할 수 있게 한다.
	
	sort(str.begin(), str.end());

	cout << str << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1486
2022-04-27 13:04:37 GMT+9
 저장 시간 : 2022-04-27 13:04:37 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "Hello" };
	// [도전] str을 sort로 정렬할 수 있게 한다.
	
	sort(str.begin(), str.end());
	
	for(char c : str)
		cout << c;
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1524
2022-04-27 13:05:30 GMT+9
 저장 시간 : 2022-04-27 13:05:30 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.
	
	sort(str.begin(), str.end());
	
	for(char c : str)
		cout << c;
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1558
2022-04-27 13:06:19 GMT+9
 저장 시간 : 2022-04-27 13:06:19 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.
	
	sort(str.begin(), str.end());
	
	unique(str.begin(), str.end());
	for(char c : str)
		cout << c;
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1578
2022-04-27 13:07:31 GMT+9
 저장 시간 : 2022-04-27 13:07:31 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	string str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.
	
	sort(str.rbegin(), str.rend());
	
	unique(str.begin(), str.end());
	for(char c : str)
		cout << c;
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1544
2022-04-27 13:08:08 GMT+9
 저장 시간 : 2022-04-27 13:08:08 GMT+9

//-----------------------------------------------------------------------------
//2022.4.27  수 34                    월23수34                          (8주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//		
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	string str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.
	
	sort(str.rbegin(), str.rend());
	
	for(char c : str)
		cout << c;
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1546
2022-05-02 11:03:41 GMT+9
 저장 시간 : 2022-05-02 11:03:41 GMT+9

//-----------------------------------------------------------------------------
//2022.5.02  월 23                    월23수34                          (9주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.

	sort(str.begin(), str.end());


	save("소스.cpp");
	save("STRING.h");
}
파일 정보 : STRING.h, 크기:3009
2022-05-02 11:03:41 GMT+9
 저장 시간 : 2022-05-02 11:03:41 GMT+9

//-----------------------------------------------------------------------------
// STRING - STL 관찰하려고 만든 자원 관리 클래스
// 
// 2022. 3. 30									Programmed by Wulong
//-----------------------------------------------------------------------------
#pragma once

#include <iostream>
#include <compare>				//C++20 shapceship operator( three-way comparator )

// 2022 - 04 - 27 STRING이 제공하는 반복자
class STRING_iterator {
public:
	// 2022 - 05 - 02 모든 표준 반복자는 이 다섯가지 타입을 정의해야 한다.
	using iterator_category = std::random_access_iterator_tag;
	using value_type = char;
	using difference_type = ptrdiff_t;
	using pointer = const char*;
	using reference = const char&;

private:
	char* p;

public:
	STRING_iterator(char* p) : p{p}{}
	// 2022 - 05 - 02 sort에 필요한 연산자들의 정의
	difference_type operator-(const STRING_iterator& rhs) const {
		return p - rhs.p;
	}

	auto operator<=>(const STRING_iterator&)const = default;

	STRING_iterator& operator++() {
		++p;
		return *this;
	}

	char& operator*() const {
		return *p;
	}

	STRING_iterator& operator--() {
		--p;
		return *this;
	}

	STRING_iterator operator+ (difference_type d)const {
		return STRING_iterator{ p + d };
	}
	STRING_iterator operator- (difference_type d)const {
		return STRING_iterator{ p - d };
	}
};


// 2022 - 04 - 27 STRING이 제공하는 역방향 반복자.
class STRING_reverse_iterator {
	char* p;

public:
	STRING_reverse_iterator(char* p) : p{ p } {}

	STRING_reverse_iterator& operator++() {
		--p;
		return *this;
	}

	char& operator*() const {
		return *(p-1);
	}

	// < , >, == , !=, <=, >=
	auto operator<=>(const STRING_reverse_iterator& rhs) const = default;

	/*bool operator!=(const STRING_reverse_iterator& rhs) const {
		std::cout << "자동보다는 사용자 우선" << std::endl;
		return p != rhs.p;
	}*/
};

class STRING {

public:
	// 2022 - 04 - 27
	using iterator = STRING_iterator;
	using reverse_iterator = STRING_reverse_iterator;

private:
	char* p;							// 확보한 자원 주소
	size_t num;							// 관리하는 바이트 수
	int id;								// 생성 시 부여한 id
	static int gid;						// 클래스 스태틱 - id 관리

public:
	STRING();
	STRING(const char* s);

	~STRING();

	STRING(const STRING& other);
	STRING& operator=(const STRING& other);
	// 이동 생성자/ 이동할당연산자 2022. 04 . 11

	STRING(STRING&& other) noexcept; // noexecept
	STRING& operator=(STRING&& other) noexcept;
	STRING operator+(const STRING& rhs) const;

	// 2022 - 04 - 27 begin()/end() 제공
	iterator begin() const {
		return iterator{ p };
	}
	iterator end() const {
		return iterator{ p + num };
	}

	reverse_iterator rbegin() const {
		return reverse_iterator{ p + num };
	}

	reverse_iterator rend() const {
		return reverse_iterator{ p };
	}

	// 2022.04.04 추가
	size_t getNum() const;

	void print(const char* s) const;

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};

파일 정보 : 소스.cpp, 크기:1578
2022-05-02 11:04:42 GMT+9
 저장 시간 : 2022-05-02 11:04:42 GMT+9

//-----------------------------------------------------------------------------
//2022.5.02  월 23                    월23수34                          (9주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.

	sort(str.begin(), str.end());

	for (char n : str) {
		cout << n << endl;
	}

	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1579
2022-05-02 11:05:09 GMT+9
 저장 시간 : 2022-05-02 11:05:09 GMT+9

//-----------------------------------------------------------------------------
//2022.5.02  월 23                    월23수34                          (9주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.

	sort(str.begin(), str.end());

	for (char n : str) {
		cout << n << " - ";
	}

	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1586
2022-05-02 11:06:35 GMT+9
 저장 시간 : 2022-05-02 11:06:35 GMT+9

//-----------------------------------------------------------------------------
//2022.5.02  월 23                    월23수34                          (9주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;

//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	STRING str{ "the quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.

	sort(str.begin(), str.end());
	unique(str.begin(), str.end());

	cout << str << endl;

	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1620
2022-05-02 11:07:56 GMT+9
 저장 시간 : 2022-05-02 11:07:56 GMT+9

//-----------------------------------------------------------------------------
//2022.5.02  월 23                    월23수34                          (9주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include"STRING.h"
#include "save.h"

using namespace std;
extern bool Check;
//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	Check = true;
	STRING str{ "the quick brown fox jumps over the lazy dog" };
	// [도전] str을 sort로 정렬할 수 있게 한다.

	sort(str.begin(), str.end());
	unique(str.begin(), str.end());

	cout << str << endl;

	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1742
2022-05-02 11:15:20 GMT+9
 저장 시간 : 2022-05-02 11:15:20 GMT+9

//-----------------------------------------------------------------------------
//2022.5.02  월 23                    월23수34                          (9주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<string>
#include <vector>
#include"STRING.h"
#include "save.h"

using namespace std;
extern bool Check;
//서로다른 자료형이 들어오니까 템플릿
template <class Iter>
void show(Iter)
{
	// [문제] Iter의 catergory로 출력하라.

	cout << typeid(Iter::iterator_category).name() << endl;

}

int main()
{
	
	// [도전] str을 sort로 정렬할 수 있게 한다.
	vector<STRING> v{ "standard", "template", "library" };

	// [문제] v의 원소를 각각 오름차순 정렬

	for (int i = 0; i < v.size(); ++i)
		sort(v[i].begin(), v[i].end(), [](char a, char b) {
		return a > b;
			});

	for (const STRING& s : v)
		cout << s << endl;

	save("소스.cpp");
	
}
파일 정보 : 소스.cpp, 크기:1745
2022-05-04 11:33:07 GMT+9
 저장 시간 : 2022-05-04 11:33:07 GMT+9

//-----------------------------------------------------------------------------
//2022.5.02  월 23                    월23수34                          (9주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교
	
}

int main()
{
	save("소스.cpp");
	save("STRING.cpp");
	save("STRING.h");
	STRING str;
	cin >> str;
	while(true) {
		cout << "찾을 글자를 입력하시오 : " << endl;
		char c;
		cin >> c;

		auto p = find(str.begin(), str.end(), c);
		if (p == str.end())
			cout << c << "는 단어에 없습니다." << endl;
		else
			cout << c << " 는 " << distance(str.begin(), p) + 1 << " 번째 입니다." << endl;
	}

	
}
파일 정보 : STRING.cpp, 크기:2554
2022-05-04 11:33:07 GMT+9
 저장 시간 : 2022-05-04 11:33:07 GMT+9

//-------------------------------------------------------------------------
// STRING.cpp - 자원을 관리하는 STL 관찰용 클래스
// 2022. 3. 30                          Programmed by Wulong
//-------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"

bool 관찰{}; // 메시지를 보려면 true로

STRING::STRING() : num{}, p{}, id{ ++cid }
{
	if (관찰)
		print("디폴트");
}

STRING::STRING(const char* str) : num{ strlen(str) }, id{ ++cid }
{
	p = new char[num];
	memcpy(p, str, num);

	if (관찰)
		print("생성자(*)");
}

STRING::STRING(const STRING& other) : num{ other.num }, id{ ++cid } // 복사 생성자
{
	p = new char[num];
	memcpy(p, other.p, num);
	if (관찰) {
		print("복사 생성");
	}
}

STRING::~STRING()
{
	if (관찰) {
		print("소멸자");
	}
	if (num)
		delete[] p;
}

STRING& STRING::operator=(const STRING& other) // 깊은 복사 (임시 객체를 리턴하지 않는다.)
{
	if (this == &other) { // 자기 자신을 할당 하는것을 방지
		return *this;
	}

	if (num) // 이미 자원을 할당하고있으면 해제
		delete[] p;

	num = other.num;
	p = new char[num];
	memcpy(p, other.p, num);

	if (관찰)
		print("복사할당");

	return *this;
}

STRING::STRING(STRING&& other) noexcept : id{ ++cid } // 2022. 4. 7 이동생성자/이동할당연산자
{
	num = other.num;
	p = other.p;

	other.num = 0;
	other.p = nullptr;

	if (관찰)
		print("이동생성");
}

STRING& STRING::operator=(STRING&& other) noexcept
{
	if (this != &other) {
		if (num)
			delete[] p;

		num = other.num;
		p = other.p;

		other.num = 0;
		other.p = nullptr;
	}

	if (관찰)
		print("이동할당");
	return *this;
}

STRING STRING::operator+(const STRING& rhs) const  // 임시 객체를 리턴하기 때문에 const
{
	STRING temp;

	temp.num = num + rhs.num;
	temp.p = new char[temp.num];
	memcpy(temp.p, p, num);
	memcpy(temp.p + num, rhs.p, rhs.num);

	return temp;
}

size_t STRING::getNum() const
{
	return num;
}

void STRING::print(const char* s)
{
	std::cout << s << ", [" << id << "] 객체 : " << this;
	if (num) {
		std::cout << " 자원 수 : " << num << " 주소 : " << (void*)p;
	}
	else
		std::cout << " 자원 없음";
	std::cout << std::endl;
}

int STRING::cid{}; //스태틱변수 초기화

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];
	return os;
}

std::istream& operator>>(std::istream& is, STRING& s) {
	std::string str;

	is >> str;

	s = STRING(str.c_str());

	return is;
}파일 정보 : STRING.h, 크기:3362
2022-05-04 11:33:07 GMT+9
 저장 시간 : 2022-05-04 11:33:07 GMT+9

//-------------------------------------------------------------------------
// STRING.h - 자원을 관리하는 STL 관찰용 클래스
// 2022. 3. 30                          Programmed by Wulong
//-------------------------------------------------------------------------
#pragma once
#include <iostream>

class STRING_iterator {
public:
	using iterator_category = std::random_access_iterator_tag;
	using value_type = char;
	using difference_type = ptrdiff_t;
	using pointer = const char*;
	using reference = const char&;

private:
	char* p;
public:
	STRING_iterator(char* p) : p{ p } {}

	// 5.2 sort에 필요한 연산들 정의
	difference_type operator-(const STRING_iterator& rhs) const { // ptrdiff_t 포인터 끼리 연산할때 쓰는 타입
		return p - rhs.p;
	}

	auto operator<=>(const STRING_iterator&) const = default;

	STRING_iterator& operator++() {
		++p;
		return *this;
	}

	char& operator*() const {
		return *p;
	}

	STRING_iterator& operator--() {
		--p;
		return *this;
	}

	STRING_iterator operator+ (difference_type d) const {
		return STRING_iterator{ p + d };
	}

	STRING_iterator operator- (difference_type d) const {
		return STRING_iterator{ p - d };
	}
};

//2022. 4. 27 STRING이 제공할 역방향 반복자
class STRING_reverse_iterator {
private:
	char* p;
public:
	STRING_reverse_iterator(char* p) : p{ p } {} // 인자값에 다른값 쓰기않기 ex) _p , this값 받지않기 ex) this->p = p.

	STRING_reverse_iterator& operator++() { // 자기자신을 바꾸니까 const ㄴㄴ
		--p;
		return *this;
	}

	char& operator*() const { // char&를 리턴했기 때문에 값을 읽어도 되고 써도된다.
		return *(p - 1);
	}

	// <, >, <=, >=, ==, != (관계 연산자 relational operator)
	// 관계 연산자는 우주선 연산자로 한번에 해결 - C++20
	// spaceship operator ( three-way comparison operator)

	auto operator<=>(const STRING_reverse_iterator& rhs) const = default;

	/*bool operator!=(const STRING_reverse_iterator& rhs) const {
		return p != rhs.p;
	}*/
};


class STRING {
public:
	using iterator = STRING_iterator;
	using reverse_iterator = STRING_reverse_iterator;
private:
	size_t num{};                // 8 자원개수
	char* p;                     // 8 자원이 있는곳 
	int id;                      // 4  생성 시 부여             + 테딩?4바이트까지 해서 24바이트
	static int cid;              // 객체가 생성될때마다 1증가
public:

	STRING();
	STRING(const char* str);

	~STRING();

	STRING(const STRING& other);
	STRING& operator=(const STRING& other);

	// 2022. 4. 7 이동생성자/이동할당연산자
	STRING(STRING&& other) noexcept;
	STRING& operator=(STRING&& other) noexcept;

	STRING operator+(const STRING& rhs) const;

	// 2022. 5. 2 default < 연산자
	bool operator < (const STRING& rhs) const {
		return num < rhs.num;
	}


	// 2022. 4. 21 begin(), end() 제공
	iterator begin() const {
		return iterator{ p };
	}
	iterator end() const {
		return iterator{ p + num };
	}

	reverse_iterator rbegin() const {
		return reverse_iterator{ p + num };
	}
	reverse_iterator rend() const {
		return reverse_iterator{ p };
	}




	size_t getNum() const; // 2022.3.30 추가

	void print(const char* s);

	friend std::ostream& operator<<(std::ostream&, const STRING&);

	// 5.2 입력반복자가 >> 로 읽을 수 있게
	friend std::istream& operator>>(std::istream&, STRING&);


};
파일 정보 : 소스.cpp, 크기:2121
2022-05-04 11:56:32 GMT+9
 저장 시간 : 2022-05-04 11:56:32 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자 종류 판정
//  - STRING의 반복자를 코딩 - 반복자는 컨테이너가 제공하는 클래스가 되어야
//  - sort(str.begin(), str.end()); STRING이 sort가 되게 하자
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

template<class 반복자, class 값>

반복자 my_find(반복자 시작위치, 반복자 끝위치, 값 찾는값)
{
	while (시작위치 != 끝위치) {
		if (*시작위치 == 찾는값)
			return 시작위치;
		++시작위치;
	}
	return 끝위치;
}

using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");
	while (true) {

		STRING str;
		cout << "단어를 입력하시오" << endl;
		cin >> str;
		cout << "찾을 글자를 입력하시오 : " << endl;
		char c;
		cin >> c;

		// my_find 만들기 

		auto p = my_find(str.begin(), str.end(), c);
		if (p == str.end())
			cout << c << "는 단어에 없습니다." << endl;
		else
			cout << c << " 는 " << distance(str.begin(), p) + 1 << " 번째 입니다." << endl;
	}


	/*save("STRING.cpp");
	save("STRING.h");
	*/
}
파일 정보 : 소스.cpp, 크기:1891
2022-05-04 12:00:02 GMT+9
 저장 시간 : 2022-05-04 12:00:02 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

template<class Iter, class Val>

Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}

using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");
	while (true) {

		STRING str;
		cout << "단어를 입력하시오" << endl;
		cin >> str;
		cout << "찾을 글자를 입력하시오 : " << endl;
		char c;
		cin >> c;

		// my_find 만들기 

		auto p = my_find(str.begin(), str.end(), c);
		if (p == str.end())
			cout << c << "는 단어에 없습니다." << endl;
		else
			cout << c << " 는 " << distance(str.begin(), p) + 1 << " 번째 입니다." << endl;
	}


	/*save("STRING.cpp");
	save("STRING.h");
	*/
}
파일 정보 : 소스.cpp, 크기:1892
2022-05-04 12:05:47 GMT+9
 저장 시간 : 2022-05-04 12:05:47 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

template<class Iter, class Val>

Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}

using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;
	cout << "단어를 입력하시오" << endl;
	cin >> str;
	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라

		auto p = find_if(str.begin(), str.end(), [](const char& c) {
			return 'p' <= c;
			});

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:1896
2022-05-04 12:06:46 GMT+9
 저장 시간 : 2022-05-04 12:06:46 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

template<class Iter, class Val>

Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}

using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;

	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라
		cout << "단어를 입력하시오" << endl;
		cin >> str;

		auto p = find_if(str.begin(), str.end(), [](const char& c) {
			return 'p' <= c;
			});

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:2050
2022-05-04 12:20:27 GMT+9
 저장 시간 : 2022-05-04 12:20:27 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

template<class Iter, class Val>

Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}
template<class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f) {

	while (b != e) {
		if (f(*b)) {
			return b;
		}
		++b;
	}

}


using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;

	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라
		cout << "단어를 입력하시오" << endl;
		cin >> str;

		auto p =my_find_if(str.begin(), str.end(), [](const char& c) {
			return 'p' <= c;
			});

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:2046
2022-05-04 12:22:15 GMT+9
 저장 시간 : 2022-05-04 12:22:15 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

template<class Iter, class Val>

Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}
template<class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f) {

	while (b != e) {
		if (f(*b)) {
			return b;
		}
		++b;
	}

}
bool f(char c) {
	return 'p' <= c;
}


using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;

	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라
		cout << "단어를 입력하시오" << endl;
		cin >> str;

		auto p = my_find_if(str.begin(), str.end(), f);

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:2088
2022-05-04 12:25:00 GMT+9
 저장 시간 : 2022-05-04 12:25:00 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

template<class Iter, class Val>

Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}
template<class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f) {

	while (b != e) {
		if (f(*b)) {
			return b;
		}
		++b;
	}

}
class XXX {
public:
	bool operator()(char c) {
		return 'p' <= c;
	}
};


using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;

	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라
		cout << "단어를 입력하시오" << endl;
		cin >> str;

		auto p = my_find_if(str.begin(), str.end(), XXX());

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:2122
2022-05-04 12:25:46 GMT+9
 저장 시간 : 2022-05-04 12:25:46 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

//template<class Iter, class Val>
//
//Iter my_find(Iter b, Iter e, Val v)
//{
//	while (b != e) {
//		if (*b == v)
//			return b;
//		++b;
//	}
//	return e;
//}

template<class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f) {

	while (b != e) {
		if (f(*b)) {
			return b;
		}
		++b;
	}
	return e;
}
class XXX {
public:
	bool operator()(char c) {
		return 'p' <= c;
	}
};


using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;

	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라
		cout << "단어를 입력하시오" << endl;
		cin >> str;

		auto p = my_find_if(str.begin(), str.end(), XXX());

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:2122
2022-05-04 12:27:25 GMT+9
 저장 시간 : 2022-05-04 12:27:25 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

//template<class Iter, class Val>
//
//Iter my_find(Iter b, Iter e, Val v)
//{
//	while (b != e) {
//		if (*b == v)
//			return b;
//		++b;
//	}
//	return e;
//}

template<class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f) {

	while (b != e) {
		if (f(*b)) {
			return b;
		}
		++b;
	}
	return e;
}
class XXX {
public:
	bool operator()(char c) {
		return 'p' <= c;
	}
};


using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;

	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라
		cout << "단어를 입력하시오" << endl;
		cin >> str;

		auto p = my_find_if(str.begin(), str.end(), XXX());

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:2124
2022-05-04 12:28:36 GMT+9
 저장 시간 : 2022-05-04 12:28:36 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//	 - String 이 제공하는 반복자가 random
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"

//template<class Iter, class Val>
//
//Iter my_find(Iter b, Iter e, Val v)
//{
//	while (b != e) {
//		if (*b == v)
//			return b;
//		++b;
//	}
//	return e;
//}

template<class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f) {

	while (b != e) {
		if (f(*b)) {
			return b;
		}
		++b;
	}
	return e;
}

class XXX {
public:
	bool operator()(char c) {
		return 'p' <= c;
	}
};


using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}
int main()
{
	save("소스.cpp");

	STRING str;

	while (true) {
		//[문제] 글자를 입력받아 'p' 보다 알파벳 순서상  크거나 같은 문자가 몇번째 문자인지  출력하라
		cout << "단어를 입력하시오" << endl;
		cin >> str;

		auto p = my_find_if(str.begin(), str.end(), XXX());

		if (p == str.end())
			cout << "p와 같거나 큰 문자는 없습니다." << endl;
		else
			cout << *p << " - " << distance(str.begin(), p) + 1 << "번 째 문자" << endl;
	}



}
파일 정보 : 소스.cpp, 크기:1377
2022-05-04 12:38:42 GMT+9
 저장 시간 : 2022-05-04 12:38:42 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}


int main()
{
	save("소스.cpp");
	
	//copy(키보드입력, 입력끝, 출력);
	copy(istream_iterator<char>{cin}, {}, ostream_iterator<char>{cout});

}

파일 정보 : 소스.cpp, 크기:1526
2022-05-04 12:47:31 GMT+9
 저장 시간 : 2022-05-04 12:47:31 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
}

int main()
{
	save("소스.cpp");
	
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, ostream_iterator<char>{cout});

}

파일 정보 : 소스.cpp, 크기:1533
2022-05-04 12:48:05 GMT+9
 저장 시간 : 2022-05-04 12:48:05 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>

#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
}

int main()
{
	save("소스.cpp");
	
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, ostream_iterator<char>{cout, " - "});

}

파일 정보 : 소스.cpp, 크기:1598
2022-05-04 12:49:05 GMT+9
 저장 시간 : 2022-05-04 12:49:05 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
}

int main()
{
	save("소스.cpp");
	vector<char> v;
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, v.begin());

	for (char c : v)
		cout << c << " - ";
	cout << endl;

}

파일 정보 : 소스.cpp, 크기:1598
2022-05-04 12:49:13 GMT+9
 저장 시간 : 2022-05-04 12:49:13 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
}

int main()
{
	save("소스.cpp");
	vector<char> v;
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, v.begin());

	for (char c : v)
		cout << c << " - ";
	cout << endl;

}

파일 정보 : 소스.cpp, 크기:1613
2022-05-04 12:49:48 GMT+9
 저장 시간 : 2022-05-04 12:49:48 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

DesIter my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
	return d;
}

int main()
{
	save("소스.cpp");
	vector<char> v;
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, v.begin());

	for (char c : v)
		cout << c << " - ";
	cout << endl;

}

파일 정보 : 소스.cpp, 크기:1664
2022-05-04 12:52:20 GMT+9
 저장 시간 : 2022-05-04 12:52:20 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
}

int main()
{
	save("소스.cpp");
	vector<char> v;
	v.reserve(100);
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, v.begin());	//공간 확보가 되어있지 않아 들어가지않는다. 

	for (char c : v)
		cout << c << " - ";
	cout << endl;
	

}

파일 정보 : 소스.cpp, 크기:1695
2022-05-04 12:55:40 GMT+9
 저장 시간 : 2022-05-04 12:55:40 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}

}

int main()
{
	save("소스.cpp");
	vector<char> v;
	v.reserve(100);
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, v.begin());	//공간 확보가 되어있지 않아 들어가지않는다. 

	char* p = v.data();

	for (int i = 0; i < 100; ++i) {
		cout << p[i] << endl;
	}
	

}

파일 정보 : 소스.cpp, 크기:1683
2022-05-04 12:56:54 GMT+9
 저장 시간 : 2022-05-04 12:56:54 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}

}

int main()
{
	save("소스.cpp");
	vector<char> v;
	v.reserve(100);
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, v.begin());	//공간 확보가 되어있지 않아 들어가지않는다. 

	for (int i = 0; i < v.size(); ++i) {
		cout << v[i];
	}
	cout << endl;


}

파일 정보 : 소스.cpp, 크기:1765
2022-05-04 12:58:51 GMT+9
 저장 시간 : 2022-05-04 12:58:51 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
// Sequence Container
//				반복자 - Iteratiors are a generalization of pointers 
//							- that allow a C++ program to work with different data structures 
//							- in a uniform manner.
// 반복자란 포인터를 추상화 한것 
// 자료구조를 일관된 방식으로 접근하기 위해서.
// 
//	Associative Container
// Unordered Associative Container
// 
//  C++ 20 concept 을 살펴보자./ (나머지 3개) module, range, coroutine
// 
// 오늘 코딩해서 알아볼 내용
//  - 반복자를 인자로 받는 알고리즘 함수를 직접 만들어 보면서
//  - 제네릭 코딩의 재미를 알아본다. 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

bool operator<(const STRING& lhs, const STRING& rhs)
{
	// 사전식 비교 알고리즘 함수S

	return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); //사전식 비교

}

template<class SrcIter, class DesIter>

void my_copy(SrcIter b, SrcIter e, DesIter d){

	while (b != e) {
		*d = *b;
		++d;
		++b;
	}

}

int main()
{
	save("소스.cpp");
	vector<char> v;
	v.reserve(100);
	//copy(키보드입력, 입력끝, 출력);
	my_copy(istream_iterator<char>{cin}, {}, back_inserter(v));	//공간 확보가 되어있지 않아 들어가지않는다. 
	//모든 카피 동작에는 사이즈를 바꾸어야하는 동작이 있기 때문에 inserter필요
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i];
	}
	cout << endl;


}

파일 정보 : 소스.cpp, 크기:810
2022-05-04 13:06:41 GMT+9
 저장 시간 : 2022-05-04 13:06:41 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

void print(int[]);

void print(int arr[10])
{
	for (int i = 0; i < 10; ++i) {
		cout << arr[i] << endl;
	}
}
int main()
{
	int a[10]{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:812
2022-05-04 13:07:27 GMT+9
 저장 시간 : 2022-05-04 13:07:27 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

void print(int[10]);

void print(int arr[10])
{
	for (int i = 0; i < 10; ++i) {
		cout << arr[i] << endl;
	}
}
int main()
{
	int a[10]{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:811
2022-05-04 13:07:36 GMT+9
 저장 시간 : 2022-05-04 13:07:36 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

void print(int[10]);

void print(int arr[10])
{
	for (int i = 0; i < 10; ++i) {
		cout << arr[i] << endl;
	}
}
int main()
{
	int a[9]{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:811
2022-05-04 13:07:59 GMT+9
 저장 시간 : 2022-05-04 13:07:59 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

void print(int[10]);

void print(int arr[10])
{
	for (int i = 0; i < 10; ++i) {
		cout << arr[i] << endl;
	}
}
int main()
{
	int a[5]{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:905
2022-05-04 13:10:34 GMT+9
 저장 시간 : 2022-05-04 13:10:34 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

void print(int*); //array는 무조건 *형으로 decay

void print(int* a) //array를 인자로 넘길때는 무조건 array의 개수를 같이 넘겨주었어야 했다. 
{
	for (int i = 0; i < 10; ++i) {
		cout << a[i] << endl;
	}
}
int main()
{
	int a[5]{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:957
2022-05-04 13:11:43 GMT+9
 저장 시간 : 2022-05-04 13:11:43 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

void print(const vector<int>&); //array는 무조건 *형으로 decay

void print(const vector<int>& a) //array를 인자로 넘길때는 무조건 array의 개수를 같이 넘겨주었어야 했다. 
{
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}
}
int main()
{
	vector a{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:988
2022-05-04 13:15:17 GMT+9
 저장 시간 : 2022-05-04 13:15:17 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include<span>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

//메모리가 contiguous 인 자료구조를 일관된 방식으로 코딩하기 위한 span(view)
void print(span<int>);

void print(span<int> a){
	cout << "스팬 - 전체 메모리 : " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}
}
int main()
{
	vector a{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1034
2022-05-04 13:16:05 GMT+9
 저장 시간 : 2022-05-04 13:16:05 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  
//-----------------------------------------------------------------------------

#include<iostream>
#include<span>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

//메모리가 contiguous 인 자료구조를 일관된 방식으로 코딩하기 위한 span(view)
void print(span<int>);

void print(span<int> a){
	cout << "스팬 - 전체 메모리 : " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}
}
int main()
{
	vector a{ 1,2,3,4,5 };

	//[문제] a를 인자로 받아 값을 전부 출력한다.
	// p를 선언하고 정의하라.
	print(a);

	int b[]{ 1,2,3,4,5,6,7,8,9,0 };
	print(b);
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1312
2022-05-09 10:43:38 GMT+9
 저장 시간 : 2022-05-09 10:43:38 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  set map 공부하기
//-----------------------------------------------------------------------------

#include<iostream>
#include<span>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

//메모리가 contiguous 인 자료구조를 일관된 방식으로 코딩하기 위한 span(view)
void print(span<int>);

void print(span<int> a) { //컨테이너처럼 사용할수 있는 
	cout << "스팬 - 전체 메모리 : " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << " ";;
	}
	cout << endl;
}

void print(span<char> a) {
	cout << "스팬 - 전체 메모리 : " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i) 
		cout << a[i] << " ";
	cout << endl;
}
int main()
{
	int b[]{ 1,2,3,4,5,6,7,8,9,10 };
	print(b);
	//[문제] print는 vector를 인자로 받아 값을 전부 출력한다.
	// print를 선언하고 정의하라
	STRING s{ "Hello, span!" };
	//print(span<char>(시작번지,갯수);
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1364
2022-05-09 10:52:47 GMT+9
 저장 시간 : 2022-05-09 10:52:47 GMT+9

//-----------------------------------------------------------------------------
//2022.5.04  수 34                    월23수34                          (9주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// 
// c++20 span
//  set map 공부하기
//-----------------------------------------------------------------------------

#include<iostream>
#include<span>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

//메모리가 contiguous 인 자료구조를 일관된 방식으로 코딩하기 위한 span(view)
void print(span<int>);

void print(span<int> a) { //컨테이너처럼 사용할수 있는 
	cout << "스팬 - 전체 메모리 : " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << " ";;
	}
	cout << endl;
}

void print(span<char> a) {
	cout << "스팬 - 전체 메모리 : " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i) 
		cout << a[i] << " ";
	cout << endl;
}
int main()
{
	int b[]{ 1,2,3,4,5,6,7,8,9,10 };
	print(b);
	//[문제] print는 vector를 인자로 받아 값을 전부 출력한다.
	// print를 선언하고 정의하라
	STRING s{ "Hello, span!" };
	//print(span<char>(시작번지, 개수));
	print(span<char>((&(*s.begin())), s.getNum()));
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:981
2022-05-09 11:14:54 GMT+9
 저장 시간 : 2022-05-09 11:14:54 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<random>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main()
{
	vector<int> v(100);
	
	for (int i = 0; i < v.size(); ++i)
		cout << format(" {:>4}", v[i]);
	cout << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1014
2022-05-09 11:15:21 GMT+9
 저장 시간 : 2022-05-09 11:15:21 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<random>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main()
{
	vector<int> v(100);
	
	iota(v.begin(), v.end(), 1);

	for (int i = 0; i < v.size(); ++i)
		cout << format(" {:>4}", v[i]);
	cout << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1138
2022-05-09 11:19:36 GMT+9
 저장 시간 : 2022-05-09 11:19:36 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre{  };

int main()
{
	vector<int> v(100);
	
	iota(v.begin(), v.end(), 1); //1부터 끝까지 넣어주는 
	shuffle(v.begin(), v.end(),dre);
	
	set<int>s{v.begin(),v.end()};

	for (int n : s)
		cout << format("{:>}", n);
	cout << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1139
2022-05-09 11:19:46 GMT+9
 저장 시간 : 2022-05-09 11:19:46 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre{  };

int main()
{
	vector<int> v(100);
	
	iota(v.begin(), v.end(), 1); //1부터 끝까지 넣어주는 
	shuffle(v.begin(), v.end(),dre);
	
	set<int>s{v.begin(),v.end()};

	for (int n : s)
		cout << format("{:>4}", n);
	cout << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1152
2022-05-09 11:20:13 GMT+9
 저장 시간 : 2022-05-09 11:20:13 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre{  };

int main()
{
	vector<int> v(100);
	
	iota(v.begin(), v.end(), 1); //1부터 끝까지 넣어주는 
	shuffle(v.begin(), v.end(),dre);
	
	set<int,greater<int>>s{v.begin(),v.end()};

	for (int n : s)
		cout << format("{:>4}", n);
	cout << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1175
2022-05-09 11:21:14 GMT+9
 저장 시간 : 2022-05-09 11:21:14 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

random_device rd;
default_random_engine dre{ rd() };

int main()
{
	vector<int> v(100);
	
	iota(v.begin(), v.end(), 1); //1부터 끝까지 넣어주는 
	shuffle(v.begin(), v.end(),dre);
	
	set<int,greater<int>>s{v.begin(),v.end()};

	for (int n : s)
		cout << format("{:>4}", n);
	cout << endl;
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1140
2022-05-09 11:38:56 GMT+9
 저장 시간 : 2022-05-09 11:38:56 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

int main()
{
	//[문제] "소스.cpp"의 단어를 set에 넣고 출력하시오.
	// set<string, less<string> > s;

	ifstream in{ "소스.cpp" };
	set<string>s{ istream_iterator<string>{in},{} };

	for (const string& s : s)
		cout << format("{:^80} ", s);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1140
2022-05-09 11:39:07 GMT+9
 저장 시간 : 2022-05-09 11:39:07 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

int main()
{
	//[문제] "소스.cpp"의 단어를 set에 넣고 출력하시오.
	// set<string, less<string> > s;
	ifstream in{ "소스.cpp" };
	set<string>s{ istream_iterator<string>{in},{} };

	for (const string& s : s)
		cout << format("{:^80} ", s);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1145
2022-05-09 11:40:01 GMT+9
 저장 시간 : 2022-05-09 11:40:01 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

int main()
{
	//[문제] "소스.cpp"의 단어를 set에 넣고 출력하시오.
	// set<string, less<string> > s;
	ifstream in{ "소스.cpp" };
	multiset<string>s{ istream_iterator<string>{in},{} };

	for (const string& s : s)
		cout << format("{:^80} ", s);

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1416
2022-05-09 11:52:35 GMT+9
 저장 시간 : 2022-05-09 11:52:35 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

int main()
{
	save("소스.cpp");
	//[문제] "소스.cpp"의 단어를 set에 넣고 출력하시오.
	// set<string, less<string> > s;
	ifstream in{ "소스.cpp" };
	multiset<string>s{ istream_iterator<string>{in},{} };

	for (const string& s : s)
		cout << format("{:^80} ", s);

	//[문제] 단어를 입력받아 set에 있는지 없는지 출력하라.
	while (true) {
		cout << "찾을 단어를 입력하시오. : ";
		string word;
		cin >> word;

		//있는지 없는 지 출력하라. -> C++ 20 연관 컨테이너 멤버 contains
		cout << boolalpha << s.contains(word) << endl;
	}
}

파일 정보 : 소스.cpp, 크기:1545
2022-05-09 12:00:22 GMT+9
 저장 시간 : 2022-05-09 12:00:22 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<vector>
#include<numeric>
#include<algorithm>
#include<random>
#include<format>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

int main()
{
	save("소스.cpp");
	//[문제] "소스.cpp"의 단어를 set에 넣고 출력하시오.
	// set<string, less<string> > s;
	ifstream in{ "소스.cpp" };
	multiset<string>s{ istream_iterator<string>{in},{} };

	for (const string& s : s)
		cout << format("{:^80} ", s);

	//[문제] 단어를 입력받아 multiset에 있다면 몇개 있는지 출력하라.
	while (true) {
		cout << "찾을 단어를 입력하시오. : ";
		string word;
		cin >> word;

		auto [하한,상한] = s.equal_range(word);				//structured - binding
		if (하한 == 상한)
			cout << "그런 단어가 존재하지 않습니다. " << endl;
		else
			cout << word << "는 " << distance(하한, 상한) << "개 가 있습니다." << endl;
		
	}
}

파일 정보 : 소스.cpp, 크기:1369
2022-05-09 12:14:47 GMT+9
 저장 시간 : 2022-05-09 12:14:47 GMT+9

//-----------------------------------------------------------------------------
//2022.5.9  월 23                    월23수34                          (10주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, 
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}
	void show() const {
		cout << name << " - " << num << endl;
	}
	};

	array<Dog, 1000>dogs;

	int main() {
		save("소스.cpp");
		//class Dog를 set<Dog>에 넣고 출력하자.
		for (const Dog& dog : dogs)
			dog.show();
	}
파일 정보 : 소스.cpp, 크기:1460
2022-05-11 11:36:14 GMT+9
 저장 시간 : 2022-05-11 11:36:14 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}
	void show() const {
		cout << name << " - " << num << endl;
	}
};

array<Dog, 1000>dogs;

int main() {
	save("소스.cpp");
	//class Dog를 set<Dog>에 넣고 출력하자.
	for (const Dog& dog : dogs)
		dog.show();
	//set<Dog>s{ dogs.begin(),dogs.end() };

	for (const Dog& dog : dogs)
		dog.show();

}
파일 정보 : 소스.cpp, 크기:1743
2022-05-11 11:42:58 GMT+9
 저장 시간 : 2022-05-11 11:42:58 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {
		return name < rhs.name;
	}

	void show() const {
		cout << name << " - " << num << endl;
	}
};

array<Dog, 1000>dogs;

int main() {
	
	/*less<Dog>{
	}*///표준에서 제공하는 클래스에 내가만든 객체를 집어넣어서 훼손시킬 이유가 없다. 

	//1. less<Dog>
	// 2. operator<(Dog, Dog);
	//  - Dog.operator<(Dog);
	// - operator(Dog,Dog);
	//class Dog를 set<Dog>에 넣고 출력하자.
	// set<Dog>는 default 로 name 오름차순 정렬한다.
	set<Dog>s{ dogs.begin(),dogs.end() };

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1446
2022-05-11 11:44:34 GMT+9
 저장 시간 : 2022-05-11 11:44:34 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {
		return name < rhs.name;
	}

	void show() const {
		cout << name << " - " << num << endl;
	}
};

int main() {
	
	set<Dog>s;
	for (int i = 0; i < 1000; ++i)
		s.emplace();

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1574
2022-05-11 11:45:53 GMT+9
 저장 시간 : 2022-05-11 11:45:53 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {
		return name < rhs.name;
	}

	void show() const {
		cout << name << " - " << num << endl;
	}
};

int main() {
	
	set<Dog>s;
	for (int i = 0; i < 1000; ++i)
		s.emplace(Dog{}); //emplace하고 안에 객체를 집어넣는 .. 아주 쓸모없는 코딩 emplace는 새로운 노드를 만들ㅇ 두고 객체를 알아서 생성하라의 의미

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1675
2022-05-11 11:52:18 GMT+9
 저장 시간 : 2022-05-11 11:52:18 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {
		return name < rhs.name;
	}
	int getNum()const { return num; }

	void show() const {
		cout << name << " - " << num << endl;
	}
};
auto 정렬기준 = [](const Dog& a, const Dog& b) {
	return a.getNum() < b.getNum(); };

int main() {
	
	// [ 문제 ] set에 정렬할 수 있는 타입을 지정해서 num 오름차순으로 정렬하는 ..

	set < Dog ,decltype(정렬기준)> s;
	for (int i = 0; i < 1000; ++i)
		s.emplace(); 

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1675
2022-05-11 11:53:11 GMT+9
 저장 시간 : 2022-05-11 11:53:11 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {
		return name < rhs.name;
	}
	int getNum()const { return num; }

	void show() const {
		cout << name << " - " << num << endl;
	}
};
auto 정렬기준 = [](const Dog& a, const Dog& b) {
	return a.getNum() < b.getNum(); };

int main() {
	
	// [ 문제 ] set에 정렬할 수 있는 타입을 지정해서 num 오름차순으로 정렬하는 ..

	set < Dog ,decltype(정렬기준)> s;
	for (int i = 0; i < 1000; ++i)
		s.emplace(); 

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1723
2022-05-11 11:53:39 GMT+9
 저장 시간 : 2022-05-11 11:53:39 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {
		return name < rhs.name;
	}
	int getNum()const { return num; }

	void show() const {
		cout << name << " - " << num << endl;
	}
};
auto 정렬기준 = [](const Dog& a, const Dog& b) {
	return a.getNum() < b.getNum(); };

int main() {
	
	// [ 문제 ] set에 정렬할 수 있는 타입을 지정해서 num 오름차순으로 정렬하는 ..

	set < Dog ,decltype(정렬기준)> s;
	for (int i = 0; i < 1000; ++i)
		s.emplace(); 

	for (const Dog& dog : s)
		dog.show();
	cout << "셋의 원소 수  - " << s.size() << endl;
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1775
2022-05-11 11:54:30 GMT+9
 저장 시간 : 2022-05-11 11:54:30 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {
		return name < rhs.name;
	}
	int getNum()const { return num; }

	void show() const {
		cout << name << " - " << num << endl;
	}
};
auto 정렬기준 = [](const Dog& a, const Dog& b) {
	return a.getNum() < b.getNum(); };

int main() {
	
	// [ 문제 ] set에 정렬할 수 있는 타입을 지정해서 num 오름차순으로 정렬하는 ..

	multiset < Dog ,decltype(정렬기준)> s;
	for (int i = 0; i < 1000; ++i)
		s.emplace(); 

	for (const Dog& dog : s)
		dog.show();
	cout << "셋의 원소 수  - " << s.size() << endl; // 967 마리가 나옴  왜? 중복된놈이 있기 때문에
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1854
2022-05-11 12:01:52 GMT+9
 저장 시간 : 2022-05-11 12:01:52 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ? 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidAlpha{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,10000 };

class Dog {
	string name;	//10글자 소문자
	int num;		//1~10000사이

public:
	Dog() {
		for (int i = 0; i < 10; ++i) {
			name += uidAlpha(dre);
		}
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {			 
		return name < rhs.name;
	}
	int getNum()const { return num; }// 한정자 cv - qualifier 

	void show() const {
		cout << name << " - " << num << endl;
	}
};
class 정렬기준 {
public:
	bool operator()(const Dog& a, const Dog& b) const {
		return a.getNum() < b.getNum(); };
};
int main() {
	
	// [ 문제 ] set에 정렬할 수 있는 타입을 지정해서 num 오름차순으로 정렬하는 ..

	multiset < Dog ,정렬기준> s;

	
	for (int i = 0; i < 1000; ++i)
		s.emplace(); 

	for (const Dog& dog : s)
		dog.show();
	cout << "셋의 원소 수  - " << s.size() << endl; // 967 마리가 나옴  왜? 중복된놈이 있기 때문에 multiset으로중복까지
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1131
2022-05-11 12:10:11 GMT+9
 저장 시간 : 2022-05-11 12:10:11 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//			-- 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;
// [문제] 키보드에서 입력한 단어를 길이순으로 정렬하여 출력하라. 
auto p = [](const string& a, const string& b) {return a.size() > b.size(); };
int main() {
	set<string, decltype(p)> s;
	string str;
	cin >> str;
	s.emplace(str);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1131
2022-05-11 12:10:23 GMT+9
 저장 시간 : 2022-05-11 12:10:23 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//			-- 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<random>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;
// [문제] 키보드에서 입력한 단어를 길이순으로 정렬하여 출력하라. 
auto p = [](const string& a, const string& b) {return a.size() > b.size(); };
int main() {
	set<string, decltype(p)> s;
	string str;
	cin >> str;
	s.emplace(str);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1073
2022-05-11 12:12:21 GMT+9
 저장 시간 : 2022-05-11 12:12:21 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//			-- 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

// [문제] 키보드에서 입력한 단어를 길이순으로 정렬하여 출력하라. 


int main() {

	set<string>s{ istream_iterator<string>{cin},{} };

	for (const string& s : s)
		format("{:^80}", s);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1073
2022-05-11 12:13:26 GMT+9
 저장 시간 : 2022-05-11 12:13:26 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//			-- 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

// [문제] 키보드에서 입력한 단어를 길이순으로 정렬하여 출력하라. 


int main() {

	set<string>s{ istream_iterator<string>{cin},{} };

	for (const string& s : s)
		format("{:^80}", s);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1211
2022-05-11 12:15:50 GMT+9
 저장 시간 : 2022-05-11 12:15:50 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//			-- 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

// [문제] 키보드에서 입력한 단어를 길이순으로 정렬하여 출력하라. 
class 길이순 {
public:
	bool operator() (const string& a, const string& b) const {
		return a.size() < b.size();
	}
};

int main() {

	set<string,길이순>s{ istream_iterator<string>{cin},{} };

	for (const string& s : s)
		cout << format("{:^80}", s);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1211
2022-05-11 12:18:26 GMT+9
 저장 시간 : 2022-05-11 12:18:26 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//			-- 
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<set> // 정렬 ,,원소를 넣으면 알아서 정렬
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;

// [문제] 키보드에서 입력한 단어를 길이순으로 정렬하여 출력하라. 
class 길이순 {
public:
	bool operator() (const string& a, const string& b) const {
		return a.size() < b.size();
	}
};

int main() {

	set<string,길이순>s{ istream_iterator<string>{cin},{} };

	for (const string& s : s)
		cout << format("{:^80}", s);

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1148
2022-05-11 12:44:13 GMT+9
 저장 시간 : 2022-05-11 12:44:13 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	//만화 제목과 주인공
	map<string, string> comics{
		{"원펀맨","사이타마"},{"원피스","쵸파"},{"빌리배트", "박쥐"} ,{"베르세르크","매의 단"}
	};

	// 만화 제목과 주인공을 출력하라
	for (const pair<string, string> comic : comics)
		cout << comic.first << " - " << comic.second << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1116
2022-05-11 12:44:55 GMT+9
 저장 시간 : 2022-05-11 12:44:55 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	//만화 제목과 주인공
	map<string, string> comics{
		{"원펀맨","사이타마"},{"원피스","쵸파"},{"빌리배트", "박쥐"} ,{"베르세르크","매의 단"}
	};

	// 만화 제목과 주인공을 출력하라
	for (auto [책, 주인공] : comics)
		cout << 책	<< " - " <<주인공<< endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1123
2022-05-11 12:45:31 GMT+9
 저장 시간 : 2022-05-11 12:45:31 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
// 
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	//만화 제목과 주인공
	map<string, string> comics{
		{"원펀맨","사이타마"},{"원피스","쵸파"},{"빌리배트", "박쥐"} ,{"베르세르크","매의 단"}
	};

	// 만화 제목과 주인공을 출력하라
	for (const auto& [책, 주인공] : comics)
		cout << 책	<< " - " <<주인공<< endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1532
2022-05-11 12:58:44 GMT+9
 저장 시간 : 2022-05-11 12:58:44 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");
	//만화 제목과 등장 인물들 
	map<string, vector<string>> comics{
		{"원펀맨",{"사이타마","제노스","실퍼팽","가로우","킹"}},
		{"원피스",{"쵸파","루피","조로","상디","프랑키","우솝","나미","로빈"}},
		{"나루토",{ "나루토","사스케","사쿠라","이타치"}} ,
		{"베르세르크",{"매의 단","그라피스","가츠"}}
	};
	// 만화 제목을 입력하면 등장인물들을 출력하라.
	while (true) {
		cout << "만화 제목을 입력하시오 : " << endl;
		string title;
		cin >> title;

		//있으면 출력하라. 
		auto [하한, 상한] = comics.equal_range(title);
		if (하한 == 상한)
			cout << "그런 책은 존재하지 않습니다. " << endl;
		else
			cout << distance(하한, 상한) << endl;

	}
}
파일 정보 : 소스.cpp, 크기:1525
2022-05-11 13:00:34 GMT+9
 저장 시간 : 2022-05-11 13:00:34 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");
	//만화 제목과 등장 인물들 
	map<string, vector<string>> comics{
		{"원펀맨",{"사이타마","제노스","실퍼팽","가로우","킹"}},
		{"원피스",{"쵸파","루피","조로","상디","프랑키","우솝","나미","로빈"}},
		{"나루토",{ "나루토","사스케","사쿠라","이타치"}} ,
		{"베르세르크",{"매의 단","그라피스","가츠"}}
	};
	// 만화 제목을 입력하면 등장인물들을 출력하라.
	while (true) {
		cout << "만화 제목을 입력하시오 : " << endl;
		string title;
		cin >> title;

		//있으면 출력하라. 
		auto [하한, 상한] = comics.equal_range(title);
		if (하한 == 상한)
			cout << "그런 책은 존재하지 않습니다. " << endl;
		else
			cout << &(하한, 상한) << endl;

	}
}
파일 정보 : 소스.cpp, 크기:1511
2022-05-11 13:06:08 GMT+9
 저장 시간 : 2022-05-11 13:06:08 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");
	//만화 제목과 등장 인물들 
	map<string, vector<string>> comics{
		{"원펀맨",{"사이타마","제노스","실퍼팽","가로우","킹"}},
		{"원피스",{"쵸파","루피","조로","상디","프랑키","우솝","나미","로빈"}},
		{"나루토",{ "나루토","사스케","사쿠라","이타치"}} ,
		{"베르세르크",{"매의 단","그라피스","가츠"}}
	};
	// 만화 제목을 입력하면 등장인물들을 출력하라.
	while (true) {
		cout << "만화 제목을 입력하시오 : " << endl;
		string title;
		cin >> title;

		//있으면 출력하라. 
		auto p = comics.find(title);
		if (p != comics.end()) {
			cout << title << " - ";
			for (const string& c : p->second)
				cout << c << endl;
		}
	}
}
파일 정보 : 소스.cpp, 크기:1527
2022-05-11 13:06:39 GMT+9
 저장 시간 : 2022-05-11 13:06:39 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");
	//만화 제목과 등장 인물들 
	map<string, vector<string>> comics{
		{"원펀맨",{"사이타마","제노스","실퍼팽","가로우","킹"}},
		{"원피스",{"쵸파","루피","조로","상디","프랑키","우솝","나미","로빈"}},
		{"나루토",{ "나루토","사스케","사쿠라","이타치"}} ,
		{"베르세르크",{"매의 단","그라피스","가츠"}}
	};
	// 만화 제목을 입력하면 등장인물들을 출력하라.
	while (true) {
		cout << "만화 제목을 입력하시오 : " << endl;
		string title;
		cin >> title;

		//있으면 출력하라. 
		auto p = comics.find(title);
		if (p != comics.end()) {
			cout << title << " - ";
			for (const string& c : p->second)
				cout << c << " ";
		}
		cout << endl;
	}
}
파일 정보 : 소스.cpp, 크기:1587
2022-05-11 13:07:12 GMT+9
 저장 시간 : 2022-05-11 13:07:12 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");
	//만화 제목과 등장 인물들 
	map<string, vector<string>> comics{
		{"원펀맨",{"사이타마","제노스","실퍼팽","가로우","킹"}},
		{"원피스",{"쵸파","루피","조로","상디","프랑키","우솝","나미","로빈"}},
		{"나루토",{ "나루토","사스케","사쿠라","이타치"}} ,
		{"베르세르크",{"매의 단","그라피스","가츠"}}
	};
	// 만화 제목을 입력하면 등장인물들을 출력하라.
	while (true) {
		cout << "만화 제목을 입력하시오 : " << endl;
		string title;
		cin >> title;

		//있으면 출력하라. 
		auto p = comics.find(title);
		if (p != comics.end()) {
			cout << title << " - ";
			for (const string& c : p->second)
				cout << c << " ";
		cout << endl;
		}
		else
			cout << " 찾으시는 만화책이 없습니다." << endl;
	}
}
파일 정보 : 소스.cpp, 크기:1080
2022-05-11 13:14:15 GMT+9
 저장 시간 : 2022-05-11 13:14:15 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<format>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");

	// [문제 ] "소스.cpp"의 소문자 갯수를 세서 출력하라.'
	map<char, int> cim;
	
	cim['x'] = 100;
	cim['a'] ++;
	cim['b']++;

	for (auto [글자, 갯수] : cim)
		cout << 글자<< "  -  " << 갯수 << endl;


}
파일 정보 : 소스.cpp, 크기:1113
2022-05-11 13:15:55 GMT+9
 저장 시간 : 2022-05-11 13:15:55 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");

	// [문제 ] "소스.cpp"의 소문자 갯수를 세서 출력하라.
	ifstream in{ "소스.cpp" };

	map<char, int> cim;
	
	char c;
	while (in >> c) {
		cim[c] ++;
	}
	
	for (auto [글자, 갯수] : cim)
		cout << 글자<< "  -  " << 갯수 << endl;


}
파일 정보 : 소스.cpp, 크기:1132
2022-05-11 13:16:31 GMT+9
 저장 시간 : 2022-05-11 13:16:31 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");

	// [문제 ] "소스.cpp"의 소문자 갯수를 세서 출력하라.
	ifstream in{ "소스.cpp" };

	map<char, int> cim;
	
	char c;
	while (in >> c) {
		if(islower(c))
			cim[c] ++;
	}
	
	for (auto [글자, 갯수] : cim)
		cout << 글자<< "  -  " << 갯수 << endl;


}
파일 정보 : 소스.cpp, 크기:1133
2022-05-11 13:18:11 GMT+9
 저장 시간 : 2022-05-11 13:18:11 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");

	// [문제 ] "소스.cpp"의 소문자 갯수를 세서 출력하라.
	ifstream in{ "소스.cpp" };

	map<char, int> cim;
	
	char c;
	while (in >> c) {
		if(islower(c))
			cim[c] ++;
	}
	
	for (auto [글자, 갯수] : cim)
		cout << 갯수 << "  -  " << 글자 << endl;


}
파일 정보 : 소스.cpp, 크기:1138
2022-05-11 13:18:45 GMT+9
 저장 시간 : 2022-05-11 13:18:45 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");

	// [문제 ] "소스.cpp"의 소문자 갯수를 세서 출력하라.
	ifstream in{ "소스.cpp" };

	map<string, int> cim;
	
	string c;
	while (in >> c) {
		//if(islower(c))
			cim[c] ++;
	}
	
	for (auto [글자, 갯수] : cim)
		cout << 글자<< "  -  " << 갯수 << endl;


}
파일 정보 : 소스.cpp, 크기:1138
2022-05-16 10:29:59 GMT+9
 저장 시간 : 2022-05-16 10:29:59 GMT+9

//-----------------------------------------------------------------------------
//2022.5.11  수 34                    월23수34                          (10주 2일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");

	// [문제 ] "소스.cpp"의 소문자 갯수를 세서 출력하라.
	ifstream in{ "소스.cpp" };

	map<string, int> cim;
	
	string c;
	while (in >> c) {
		//if(islower(c))
			cim[c] ++;
	}
	
	for (auto [글자, 갯수] : cim)
		cout << 글자<< "  -  " << 갯수 << endl;


}
파일 정보 : 소스.cpp, 크기:1172
2022-05-16 10:31:27 GMT+9
 저장 시간 : 2022-05-16 10:31:27 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {
	save("소스.cpp");

	// [문제 ] "소스.cpp"의 소문자 갯수를 세서 출력하라.
	ifstream in{ "소스.cpp" };

	map<string, int> cim;
	
	string c;
	while (in >> c) {
		//if(islower(c))
			cim[c] ++;
	}
	
	for (auto [글자, 갯수] : cim)
		cout << 글자<< "  -  " << 갯수 << endl;


}
파일 정보 : 소스.cpp, 크기:1013
2022-05-16 10:44:41 GMT+9
 저장 시간 : 2022-05-16 10:44:41 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");

	// 영화제목/ 주인공한명 
	map<string, string> movies;

	movies.insert({ "기생충", "송강호" });
	

}
파일 정보 : 소스.cpp, 크기:1666
2022-05-16 11:02:07 GMT+9
 저장 시간 : 2022-05-16 11:02:07 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");

	// 영화제목/ 주인공한명 
	map<string, string> movies;

	movies.insert({ "기생충", "송강호" });
	movies.insert(pair<string,string>{ "인셉션","디카프리오" }); //<-이게 정식    키값은 변경 불가
	movies.insert(make_pair("혹성탈출", "찰턴 헤스턴")); //타입을 유추해서 집어넣는
	//movies["파이트 클럽"] = "브래드 피트"; // 맵을 연관 배열처럼 사용할 수 있다.  배열기호에 숫자가 아닌것
	movies.operator[]("파이트클럽") = "브래드 피트";

	while (true) {
		cout << "영화제목? ";
		string title;
		cin >> title;

		//있으면 배우를 출력, 없으면 없다고 출력, 다른방법으로 
		auto p= movies.find(title);
		if (p == movies.end())
			cout << "리스트에 없습니다" << endl;
		else
			cout << title << " - " << p->second << endl;
	}

}
파일 정보 : 소스.cpp, 크기:1619
2022-05-16 11:04:28 GMT+9
 저장 시간 : 2022-05-16 11:04:28 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");

	// 영화제목/ 주인공한명 
	map<string, string> movies;

	movies.insert({ "기생충", "송강호" });
	movies.insert(pair<string,string>{ "인셉션","디카프리오" }); //<-이게 정식    키값은 변경 불가
	movies.insert(make_pair("혹성탈출", "찰턴 헤스턴")); //타입을 유추해서 집어넣는
	//movies["파이트 클럽"] = "브래드 피트"; // 맵을 연관 배열처럼 사용할 수 있다.  배열기호에 숫자가 아닌것
	movies.operator[]("파이트클럽") = "브래드 피트";

	while (true) {
		cout << "영화제목? ";
		string title;
		cin >> title;
		// 연관컨테이너에서 key가 있나 없나를 알고싶다면
		// c++20 contains를 사용한다.

		if (movies.contains(title))
			cout << title<<" - " << movies[title] << endl;
	}

}
파일 정보 : 소스.cpp, 크기:1207
2022-05-16 11:08:10 GMT+9
 저장 시간 : 2022-05-16 11:08:10 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>v;
	string str;
	while (in >> str)
	{
		v.push_back(str);
	}
	for (const string& a : v)
		cout << a << endl;
	
	

}
파일 정보 : 소스.cpp, 크기:1230
2022-05-16 11:16:20 GMT+9
 저장 시간 : 2022-05-16 11:16:20 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 갯수를 출력하라.
	//[a] - 2000;
	//[z] - 200;
	
}
파일 정보 : 소스.cpp, 크기:1374
2022-05-16 11:18:37 GMT+9
 저장 시간 : 2022-05-16 11:18:37 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 갯수를 출력하라.
	//[a] - 2000;
	//[z] - 200;
	string c;
	map<string, int> cim;
	while (in >> c) {
		cim[c]++;
	}
	for (auto [글자, 갯수] : cim)
		cout << 글자 << " - " << 갯수 << endl;
}
파일 정보 : 소스.cpp, 크기:1374
2022-05-16 11:18:42 GMT+9
 저장 시간 : 2022-05-16 11:18:42 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 갯수를 출력하라.
	//[a] - 2000;
	//[z] - 200;
	string c;
	map<string, int> cim;
	while (in >> c) {
		cim[c]++;
	}
	for (auto [글자, 갯수] : cim)
		cout << 글자 << " - " << 갯수 << endl;
}
파일 정보 : 소스.cpp, 크기:1465
2022-05-16 11:34:52 GMT+9
 저장 시간 : 2022-05-16 11:34:52 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 개수를 출력하라.
	//[a] - 2000;
	//[z] - 200;

	map<char, int> 문자개수;
	for (const string& 단어 : 소설)
		for (char 문자 : 단어)
			if (islower(문자))
				문자개수[문자]++;
	
	//결과 출력
	for (pair<char, int> p : 문자개수)
		cout << p.first << " - " << p.second << endl;
}
파일 정보 : 소스.cpp, 크기:1478
2022-05-16 11:35:25 GMT+9
 저장 시간 : 2022-05-16 11:35:25 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 개수를 출력하라.
	//[a] - 2000;
	//[z] - 200;

	map<char, int> 문자개수;
	for (const string& 단어 : 소설)
		for (char 문자 : 단어)
			if (islower(문자))
				문자개수[문자]++;
	
	//결과 출력
	for (pair<char, int> p : 문자개수)
		cout <<"[" <<  p.first <<"]" << " - " << p.second << endl;
}
파일 정보 : 소스.cpp, 크기:1535
2022-05-16 11:36:34 GMT+9
 저장 시간 : 2022-05-16 11:36:34 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 개수를 출력하라.
	//[a] - 2000;
	//[z] - 200;

	map<char, int> 문자개수;
	for (const string& 단어 : 소설)
		for (char 문자 : 단어)
			if (islower(문자))
				문자개수[문자]++;
	
	//결과 출력
	cout << "map의 원소 수 - " << 문자개수.size() << endl;
	for (pair<char, int> p : 문자개수)
		cout <<"[" <<  p.first <<"]" << " - " << p.second << endl;
}
파일 정보 : 소스.cpp, 크기:1792
2022-05-16 11:46:48 GMT+9
 저장 시간 : 2022-05-16 11:46:48 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 개수를 출력하라.
	//[a] - 2000;
	//[z] - 200;

	map<char, int> 문자개수;
	for (const string& 단어 : 소설)
		for (char 문자 : 단어)
			if (islower(문자))
				문자개수[문자]++;
	
	//개수 기준 내림차순으로 결과를 출력
	cout << "map의 원소 수 - " << 문자개수.size() << endl;
	for (pair<char, int> p : 문자개수)
		cout <<"[" <<  p.first <<"]" << " - " << p.second << endl;

	vector<pair<char, int>> w{ 문자개수.begin(),문자개수.end() };
	sort(w.begin(), w.end(), [](pair<char, int>a, pair<char, int>b) {return a.second > b.second; });
	for (auto [x, y] : w) {
		cout << x << " - " << y << endl;
 	}
}
파일 정보 : 소스.cpp, 크기:1793
2022-05-16 11:49:12 GMT+9
 저장 시간 : 2022-05-16 11:49:12 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 개수를 출력하라.
	//[a] - 2000;
	//[z] - 200;

	map<char, int> 문자개수;
	for (const string& 단어 : 소설)
		for (char 문자 : 단어)
			if (islower(문자))
				문자개수[문자]++;
	
	//개수 기준 내림차순으로 결과를 출력
	cout << "map의 원소 수 - " << 문자개수.size() << endl;
	for (pair<char, int> p : 문자개수)
		cout <<"[" <<  p.first <<"]" << " - " << p.second << endl;

	vector<pair<char, int>> w{ 문자개수.begin(),문자개수.end() };
	sort(w.begin(), w.end(), [](auto a, auto b) {return a.second > b.second; });
	for (auto [문자, 개수] : w) 
		cout<<"[" << 문자 <<"]" << " - " << 개수 << endl;
 	
}
파일 정보 : 소스.cpp, 크기:1849
2022-05-16 11:49:47 GMT+9
 저장 시간 : 2022-05-16 11:49:47 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 개수를 출력하라.
	//[a] - 2000;
	//[z] - 200;

	map<char, int> 문자개수;
	for (const string& 단어 : 소설)
		for (char 문자 : 단어)
			if (islower(문자))
				문자개수[문자]++;
	
	//개수 기준 내림차순으로 결과를 출력
	cout << "map의 원소 수 - " << 문자개수.size() << endl;
	for (pair<char, int> p : 문자개수)
		cout <<"[" <<  p.first <<"]" << " - " << p.second << endl;
	cout << "내림차순으로 정렬 후 ---------------" << endl;
	vector<pair<char, int>> w{ 문자개수.begin(),문자개수.end() };
	sort(w.begin(), w.end(), [](auto a, auto b) {return a.second > b.second; });
	for (auto [문자, 개수] : w) 
		cout<<"[" << 문자 <<"]" << " - " << 개수 << endl;
 	
}
파일 정보 : 소스.cpp, 크기:1577
2022-05-16 11:53:46 GMT+9
 저장 시간 : 2022-05-16 11:53:46 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 소문자별로 개수를 출력하라.
	//[a] - 2000;
	//[z] - 200;

	map<char, int> 문자개수;
	for (const string& 단어 : 소설)
		for (char 문자 : 단어)
			if (islower(문자))
				문자개수[문자]++;

	//개수 기준 내림차순으로 결과를 출력
	map<int, char > m;
	for (auto [문자, 개수] : 문자개수)
		m.insert({ 개수,문자 });

	for (auto [개수, 문자] : m)
		cout << "[" << 문자 << "]" << " = " << 개수 << endl;
}
파일 정보 : 소스.cpp, 크기:1387
2022-05-16 11:57:36 GMT+9
 저장 시간 : 2022-05-16 11:57:36 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 많이 출현한 단어 순으로 출력하라.
	map<string, int> 단어개수;
	for (const string& 단어 : 소설)
				단어개수[단어]++;
	for (auto [단어, 개수] : 단어개수) {
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
	}
}
파일 정보 : 소스.cpp, 크기:1603
2022-05-16 12:00:14 GMT+9
 저장 시간 : 2022-05-16 12:00:14 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 많이 출현한 단어 순으로 출력하라.
	map<string, int> 단어개수;
	for (const string& 단어 : 소설)
				단어개수[단어]++;
	for (auto [단어, 개수] : 단어개수) {
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
	}
	vector<pair<string, int>>m{ 단어개수.begin(),단어개수.end() };
	sort(m.begin(), m.end(), [](auto a, auto b) {return a.second > b.second; });
	for (auto [단어, 개수] : m)
		cout << 단어 << " - " << 개수 << endl;
}
파일 정보 : 소스.cpp, 크기:1666
2022-05-16 12:03:13 GMT+9
 저장 시간 : 2022-05-16 12:03:13 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 많이 출현한 단어 순으로 출력하라.
	map<string, int> 단어개수;
	for (const string& 단어 : 소설)
				단어개수[단어]++;
	for (auto [단어, 개수] : 단어개수) {
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
	}
	cout << "단어 내림차순 결과 ------------" << endl;
	vector<pair<string, int>>m{ 단어개수.begin(),단어개수.end() };
	sort(m.begin(), m.end(), [](auto a, auto b) {return a.second > b.second; });
	for (auto [단어, 개수] : m)
		cout << "["<<단어<<"]" << " - " << 개수 << endl;
}
파일 정보 : 소스.cpp, 크기:1651
2022-05-16 12:09:01 GMT+9
 저장 시간 : 2022-05-16 12:09:01 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 많이 출현한 단어 순으로 출력하라.
	map<string, int> 단어개수;
	for (const string& 단어 : 소설)
				단어개수[단어]++;
	for (auto [단어, 개수] : 단어개수) {
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
	}
	cout << "단어 내림차순 결과 ------------" << endl;
	map<int, string,greater<int>> 개수단어;
	for (auto [단어, 개수] : 단어개수)
		개수단어[개수] = 단어;
	//결과출력
	for (auto [개수, 단어] : 개수단어)
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
}
파일 정보 : 소스.cpp, 크기:1664
2022-05-16 12:12:52 GMT+9
 저장 시간 : 2022-05-16 12:12:52 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} };
	cout << 소설.size() << endl;

	//[문제] 많이 출현한 단어 순으로 출력하라.
	map<string, int> 단어개수;
	for (const string& 단어 : 소설)
				단어개수[단어]++;
	for (auto [단어, 개수] : 단어개수) {
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
	}
	cout << "단어 내림차순 결과 ------------" << endl;
	multimap<int, string,greater<int>> 개수단어;
	for (auto [단어, 개수] : 단어개수)
		개수단어.insert({개수, 단어});
	//결과출력
	for (auto [개수, 단어] : 개수단어)
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
}
파일 정보 : 소스.cpp, 크기:1567
2022-05-16 12:13:34 GMT+9
 저장 시간 : 2022-05-16 12:13:34 GMT+9

//-----------------------------------------------------------------------------
//2022.5.16  월23                    월23수34                          (11주 1일)
//
//  자원을 관리하는 클래스 - STRING - 컨테이너 , 반복자, 알고리즘
//	컨테이너 - 다른 객체를 저장하는 객체	
//	Associative Container
// Unordered Associative Container
// set - 원소를 항상 정렬상태로 유지, (빨리 찾기 위한 ) 찾기, 제거, 추가(  O(log n)  )
//			--set의 주요 동작,  멤버 contains, (C++20)
//			-- 내가 만든 type을 set에 넣으려면 ?  - 정렬 타입을 알려줘야 한다. 
//	map
//			
// c++20 span
//  set map 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<string>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;


int main() {

	save("소스.cpp");
	//[문제]  e-class 에서 "Frankenstein.txt"를 vector<string>에 읽어라
	// 모두 몇단어 인지 출력하라. 
	ifstream in{ "Frankenstein.txt" };
	vector<string>소설{ istream_iterator<string>{in},{} }; //컨테이너 안에 바로 string으로 in을 불러옴 
	cout << 소설.size() << endl;

	//[문제] 많이 출현한 단어 순으로 출력하라.
	map<string, int> 단어개수;
	for (const string& 단어 : 소설)
				단어개수[단어]++;

	cout << "단어 내림차순 결과 ------------" << endl;
	multimap<int, string,greater<int>> 개수단어;
	for (auto [단어, 개수] : 단어개수)
		개수단어.insert({개수, 단어});
	//결과출력
	for (auto [개수, 단어] : 개수단어)
		cout << "[" << 단어 << "]" << " - " << 개수 << endl;
}
파일 정보 : 소스.cpp, 크기:780
2022-05-18 11:35:05 GMT+9
 저장 시간 : 2022-05-18 11:35:05 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

int main() {
	
	unordered_set<int> us{ 1,2,3,4 }; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	for (int n : us)
		cout << n << " ";
	cout << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:861
2022-05-18 11:36:00 GMT+9
 저장 시간 : 2022-05-18 11:36:00 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

int main() {
	
	unordered_set<int> us{ 1,2,3,4 }; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	for (int n : us)
		cout << n << " ";
	cout << endl;
	
	us.insert(-1);
	
	for (int n : us)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:940
2022-05-18 11:36:47 GMT+9
 저장 시간 : 2022-05-18 11:36:47 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

int main() {
	
	unordered_set<int> us{ 1,2,3,4 }; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	for (int n : us)
		cout << n << " ";
	cout << endl;
	
	us.insert(-1);
	
	for (int n : us)
		cout << n << " ";
	cout << endl;

	us.insert(-2);

	for (int n : us)
		cout << n << " ";
	cout << endl;


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1108
2022-05-18 11:53:47 GMT+9
 저장 시간 : 2022-05-18 11:53:47 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

int main() {
	
	save("소스.cpp");
	unordered_set<int> us{ 1,2,3,4 }; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 int를 입력하라: " << endl;
		int num;
		cin >> num;
		
		
	}
}
파일 정보 : 소스.cpp, 크기:1125
2022-05-18 11:54:11 GMT+9
 저장 시간 : 2022-05-18 11:54:11 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

int main() {
	
	save("소스.cpp");
	unordered_set<int> us{ 1,2,3,4 }; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 int를 입력하라: " << endl;
		int num;
		cin >> num;

		us.insert(num);
		
	}
}
파일 정보 : 소스.cpp, 크기:1125
2022-05-18 11:56:45 GMT+9
 저장 시간 : 2022-05-18 11:56:45 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

int main() {
	
	save("소스.cpp");
	unordered_set<int> us{ 1,2,3,4 }; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 int를 입력하라: " << endl;
		int num;
		cin >> num;

		us.insert(num);
		
	}
}
파일 정보 : 소스.cpp, 크기:1130
2022-05-18 11:57:58 GMT+9
 저장 시간 : 2022-05-18 11:57:58 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

int main() {
	
	save("소스.cpp");
	unordered_multiset<int> us{ 1,2,3,4 }; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 int를 입력하라: " << endl;
		int num;
		cin >> num;

		us.insert(num);
		
	}
}
파일 정보 : 소스.cpp, 크기:1360
2022-05-18 12:11:26 GMT+9
 저장 시간 : 2022-05-18 12:11:26 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

template <>									// <-- 	
class hash<STRING> {					// <--템플릿을 특수화 한다.
public:
	size_t operator()(const STRING& s) const {
		return hash<string>()(string(s.begin(), s.end()));
	}
};

int main() {
	
	save("소스.cpp");
	unordered_set<STRING> us{"Standard", " Template","Library"}; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 STRING를 입력하라: " << endl;
		STRING str;
		cin >> str;

		us.insert(str);
		
	}
}
파일 정보 : 소스.cpp, 크기:1425
2022-05-18 12:13:03 GMT+9
 저장 시간 : 2022-05-18 12:13:03 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

template <>									// <-- 	
class hash<STRING> {					// <--템플릿을 특수화 한다.
public:
	size_t operator()(const STRING& s) const {
		size_t val = hash<string>()(string(s.begin(), s.end()));
		cout << "해셔의 출력 - " << val << endl;
		return val;
	}
};

int main() {
	
	save("소스.cpp");
	unordered_set<STRING> us{"Standard", " Template","Library"}; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 STRING를 입력하라: " << endl;
		STRING str;
		cin >> str;

		us.insert(str);
		
	}
}
파일 정보 : 소스.cpp, 크기:1429
2022-05-18 12:13:33 GMT+9
 저장 시간 : 2022-05-18 12:13:33 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

template <>									// <-- 	
class hash<STRING> {					// <--템플릿을 특수화 한다.
public:
	size_t operator()(const STRING& s) const {
		size_t val = hash<string>()(string(s.begin(), s.end()));
		cout << "해셔의 출력 - " << (val)%8 << endl;
		return val;
	}
};

int main() {
	
	save("소스.cpp");
	unordered_set<STRING> us{"Standard", " Template","Library"}; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 STRING를 입력하라: " << endl;
		STRING str;
		cin >> str;

		us.insert(str);
		
	}
}
파일 정보 : 소스.cpp, 크기:1428
2022-05-18 12:13:51 GMT+9
 저장 시간 : 2022-05-18 12:13:51 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

template <>									// <-- 	
class hash<STRING> {					// <--템플릿을 특수화 한다.
public:
	size_t operator()(const STRING& s) const {
		size_t val = hash<string>()(string(s.begin(), s.end()));
		cout << "해셔의 출력 - " << (val)%8 << endl;
		return val;
	}
};

int main() {
	
	save("소스.cpp");
	unordered_set<STRING> us{"Standard", "Template","Library"}; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 STRING를 입력하라: " << endl;
		STRING str;
		cin >> str;

		us.insert(str);
		
	}
}
파일 정보 : 소스.cpp, 크기:1464
2022-05-18 12:14:39 GMT+9
 저장 시간 : 2022-05-18 12:14:39 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
// 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool check;

template <>									// <-- 	
class hash<STRING> {					// <--템플릿을 특수화 한다.
public:
	size_t operator()(const STRING& s) const {
		size_t val = hash<string>()(string(s.begin(), s.end()));
		cout << "해셔의 출력 - " << val <<" 버킷 크기로 나눈 값 - "<< (val) % 8 << endl;
		return val;
	}
};

int main() {
	
	save("소스.cpp");
	unordered_set<STRING> us{"Standard", "Template","Library"}; //순서가 없다.  push_back이라는 멤버자체가 없다 순서를 관리하는것은 니멋대로

	while (true){
		// 현재 메모리를 그림으로 출력
		cout << endl;
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[ " << i << " ] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << " - " << *p;
			cout << endl;
		}
		// 추가할 데이터를 입력 받는다.
		cout << endl;
		cout << "추가할 STRING를 입력하라: " << endl;
		STRING str;
		cin >> str;

		us.insert(str);
		
	}
}
파일 정보 : 소스.cpp, 크기:1486
2022-05-18 12:37:11 GMT+9
 저장 시간 : 2022-05-18 12:37:11 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1'0000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << "벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		for (int n : toFind)
			find(v.begin(), v.end(), n);

	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1600
2022-05-18 12:40:15 GMT+9
 저장 시간 : 2022-05-18 12:40:15 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1'0000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << "벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl;
	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1598
2022-05-18 12:40:55 GMT+9
 저장 시간 : 2022-05-18 12:40:55 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << "벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl;
	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1837
2022-05-18 12:44:30 GMT+9
 저장 시간 : 2022-05-18 12:44:30 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include<chrono>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << " 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 벡터에서 걸린 시간 - " << et << endl;
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl;
	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:2451
2022-05-18 12:49:14 GMT+9
 저장 시간 : 2022-05-18 12:49:14 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include<chrono>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << " 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 벡터에서 걸린 시간 - " << et << endl;
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//set의 찾기 실력 
		set<int>s{ numbers.begin(),numbers.end() };
		
		cout << " 셋의 원소 수 - " << s.size() << endl;
		cout << " 셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = s.find(n);
			if (p != s.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 셋에서 걸린 시간 - " << et << endl;
		cout << " 셋에서 찾은 갯수 - " << cnt << endl;
	}



	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:2433
2022-05-18 12:50:41 GMT+9
 저장 시간 : 2022-05-18 12:50:41 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include<chrono>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << " 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 벡터에서 걸린 시간 - " << et << endl;
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//set의 찾기 실력 
		set<int>s{ numbers.begin(),numbers.end() };
		
		cout << " 셋의 원소 수 - " << s.size() << endl;
		cout << " 셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 셋에서 걸린 시간 - " << et << endl;
		cout << " 셋에서 찾은 갯수 - " << cnt << endl;
	}



	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:3074
2022-05-18 12:52:58 GMT+9
 저장 시간 : 2022-05-18 12:52:58 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include<chrono>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << " 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 벡터에서 걸린 시간 - " << et << endl;
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//set의 찾기 실력 
		set<int>s{ numbers.begin(),numbers.end() };
		
		cout << " 셋의 원소 수 - " << s.size() << endl;
		cout << " 셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 셋에서 걸린 시간 - " << et << endl;
		cout << " 셋에서 찾은 갯수 - " << cnt << endl;
	}

	{	//unorderd_set의 찾기 실력 
		unordered_set<int>s{ numbers.begin(),numbers.end() };

		cout << " 언오더드셋의 원소 수 - " << s.size() << endl;
		cout << " 언오더드셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 언오드드셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 언오더드셋에서 걸린 시간 - " << et << endl;
		cout << " 언오더드셋에서 찾은 갯수 - " << cnt << endl;
	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:3091
2022-05-18 12:54:41 GMT+9
 저장 시간 : 2022-05-18 12:54:41 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include<chrono>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 10000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << " 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 벡터에서 걸린 시간 - " << et << endl;
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//set의 찾기 실력 
		set<int>s{ numbers.begin(),numbers.end() };
		
		cout << " 셋의 원소 수 - " << s.size() << endl;
		cout << " 셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 셋에서 걸린 시간 - " << et << endl;
		cout << " 셋에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//unorderd_set의 찾기 실력 
		unordered_set<int>s{ numbers.begin(),numbers.end() };

		cout << " 언오더드셋의 원소 수 - " << s.size() << endl;
		cout << " 언오더드셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 언오드드셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 언오더드셋에서 걸린 시간 - " << et << endl;
		cout << " 언오더드셋에서 찾은 갯수 - " << cnt << endl << endl;
	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:3784
2022-05-18 13:04:55 GMT+9
 저장 시간 : 2022-05-18 13:04:55 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include<chrono>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 1000> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << " 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 벡터에서 걸린 시간 - " << et << endl;
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//정렬된vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		sort(v.begin(), v.end());
		cout << " 정렬된 벡터의 원소 수 - " << v.size() << endl;
		cout << " 정렬된 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 정렬된 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			if (binary_search(v.begin(), v.end(), n))
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 정렬된 벡터에서 걸린 시간 - " << et << endl;
		cout << " 정렬된 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//set의 찾기 실력 
		set<int>s{ numbers.begin(),numbers.end() };
		
		cout << " 셋의 원소 수 - " << s.size() << endl;
		cout << " 셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 셋에서 걸린 시간 - " << et << endl;
		cout << " 셋에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//unorderd_set의 찾기 실력 
		unordered_set<int>s{ numbers.begin(),numbers.end() };

		cout << " 언오더드셋의 원소 수 - " << s.size() << endl;
		cout << " 언오더드셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 언오드드셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 언오더드셋에서 걸린 시간 - " << et << endl;
		cout << " 언오더드셋에서 찾은 갯수 - " << cnt << endl << endl;
	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:3782
2022-05-18 13:05:52 GMT+9
 저장 시간 : 2022-05-18 13:05:52 GMT+9

//-----------------------------------------------------------------------------
//2022.5.18  수34                    월23수34                          (11주 2일)
//
// unordered Associative Container
//  - 구조 파악 
//  - STRING을 unorderd_set 에 원소로 넣으려면 ? 
//  
//  컨테이너의 찾기 실력 검증 
//  비교할 컨테이너 vector / set / unordered_set
//  컨테이너의 원소 - 10000000개의 int
//  찾아볼 원소 - 1'0000개의 int가 천만개를 갖고있는 컨테이너에 있는지 찾는다.
//  비교 - 걸리는 시간 비교
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<array>
#include<vector>
#include<set>
#include<unordered_set>
#include<random>
#include<algorithm>
#include<chrono>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

array<int, 1000'0000>numbers;
array<int, 10> toFind;
default_random_engine dre;
uniform_int_distribution uid{ 1,1000'00000 };

int main() {
	
	//데이터 준비
	for (int& n : numbers)
		n = uid(dre);
	//찾을 데이터 준비
	for (int& n : toFind)
		n = uid(dre);

	{	//vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		shuffle(v.begin(), v.end(),dre);
		cout << " 벡터의 원소 수 - " << v.size() << endl;
		cout << " 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 벡터에서 걸린 시간 - " << et << endl;
		cout << " 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//정렬된vector의 찾기 실력 
		vector<int>v{ numbers.begin(),numbers.end() };
		sort(v.begin(), v.end());
		cout << " 정렬된 벡터의 원소 수 - " << v.size() << endl;
		cout << " 정렬된 벡터에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 정렬된 벡터에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		for (int n : toFind) {
			if (binary_search(v.begin(), v.end(), n))
				cnt++;
		}
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 정렬된 벡터에서 걸린 시간 - " << et << endl;
		cout << " 정렬된 벡터에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//set의 찾기 실력 
		set<int>s{ numbers.begin(),numbers.end() };
		
		cout << " 셋의 원소 수 - " << s.size() << endl;
		cout << " 셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 셋에서 걸린 시간 - " << et << endl;
		cout << " 셋에서 찾은 갯수 - " << cnt << endl << endl;
	}

	{	//unorderd_set의 찾기 실력 
		unordered_set<int>s{ numbers.begin(),numbers.end() };

		cout << " 언오더드셋의 원소 수 - " << s.size() << endl;
		cout << " 언오더드셋에서 찾아볼 원소 수 - " << toFind.size() << endl;
		cout << " 언오드드셋에서 찾는 중 ... ";

		auto start = chrono::steady_clock::now();
		int cnt{};
		// C++20
		for (int n : toFind)
			if (s.contains(n))
				cnt++;
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();
		cout << " 언오더드셋에서 걸린 시간 - " << et << endl;
		cout << " 언오더드셋에서 찾은 갯수 - " << cnt << endl << endl;
	}


	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1060
2022-05-23 11:05:45 GMT+9
 저장 시간 : 2022-05-23 11:05:45 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() {
	vector<STRING>v{ "STL","Algorithm", "Library" };

	// v의 원소들이 전부 첫글자가 대문자니??
	int count{};
	for (int i = 0; i < v.size(); ++i) {
		if (isupper(*v[i].begin()))
			++count;
	}
	if (count == v.size())
		cout << " 전부 대문자 입니다. " << endl;
	else
		cout << " 전부가 대문자는 아니다." << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1060
2022-05-23 11:06:25 GMT+9
 저장 시간 : 2022-05-23 11:06:25 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() {
	vector<STRING>v{ "STL","algorithm", "Library" };

	// v의 원소들이 전부 첫글자가 대문자니??
	int count{};
	for (int i = 0; i < v.size(); ++i) {
		if (isupper(*v[i].begin()))
			++count;
	}
	if (count == v.size())
		cout << " 전부 대문자 입니다. " << endl;
	else
		cout << " 전부가 대문자는 아니다." << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1091
2022-05-23 11:11:07 GMT+9
 저장 시간 : 2022-05-23 11:11:07 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() {
	vector<STRING>v{ "STL","algorithm", "Library" };

	// v의 원소들이 전부 첫글자가 대문자니??
	auto 첫글자가대문자 = [](const STRING& s) {
		if (isupper(*s.begin()))
			return true;
		return false;
	};

	if (all_of(v.begin(), v.end(), 첫글자가대문자))
		cout << " 전부 대문자 입니다." << endl;
	else
		cout << " 소문자도 있습니다. " << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1132
2022-05-23 11:34:38 GMT+9
 저장 시간 : 2022-05-23 11:34:38 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

template<class iter,class UP>

bool allof(iter 시작,iter 끝,UP 판단) 
{
	while (시작 != 끝) {
		if (!판단(*시작))
			return false;
		++시작;
	}
	return true;
}

int main() {

	vector<int>v{2,4,6,8,10 };

	// v의 원소들이 전부 짝수니?
	

	if (allof(v.begin(), v.end(), [](int n) {return n % 2 == 0; }))
		cout << " 전부 짝수 입니다." << endl;
	else
		cout << " 홀수도 있습니다. " << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1135
2022-05-23 11:34:44 GMT+9
 저장 시간 : 2022-05-23 11:34:44 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

template<class iter,class UP>

bool allof(iter 시작,iter 끝,UP 판단) 
{
	while (시작 != 끝) {
		if (!판단(*시작))
			return false;
		++시작;
	}
	return true;
}

int main() {

	vector<int>v{2,4,6,8,10,13 };

	// v의 원소들이 전부 짝수니?
	

	if (allof(v.begin(), v.end(), [](int n) {return n % 2 == 0; }))
		cout << " 전부 짝수 입니다." << endl;
	else
		cout << " 홀수도 있습니다. " << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1132
2022-05-23 11:34:57 GMT+9
 저장 시간 : 2022-05-23 11:34:57 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

template<class iter,class UP>

bool allof(iter 시작,iter 끝,UP 판단) 
{
	while (시작 != 끝) {
		if (!판단(*시작))
			return false;
		++시작;
	}
	return true;
}

int main() {

	vector<int>v{2,4,6,8,10,13 };

	// v의 원소들이 전부 짝수니?
	if (allof(v.begin(), v.end(), [](int n) {return n % 2 == 0; }))
		cout << " 전부 짝수 입니다." << endl;
	else
		cout << " 홀수도 있습니다. " << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:922
2022-05-23 11:40:35 GMT+9
 저장 시간 : 2022-05-23 11:40:35 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	STRING s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams" };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	
	while (true) {
		cout << s << endl;
	}

}
파일 정보 : 소스.cpp, 크기:967
2022-05-23 11:41:11 GMT+9
 저장 시간 : 2022-05-23 11:41:11 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	STRING s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams" };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << s << "\r";
	}

}
파일 정보 : 소스.cpp, 크기:1013
2022-05-23 11:42:04 GMT+9
 저장 시간 : 2022-05-23 11:42:04 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	STRING s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams" };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << s << "\r";
		rotate(s.begin(), s.begin() + 1, s.end());
	}

}
파일 정보 : 소스.cpp, 크기:1069
2022-05-23 11:42:58 GMT+9
 저장 시간 : 2022-05-23 11:42:58 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	STRING s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams" };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << s << "\r";
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:1070
2022-05-23 11:43:10 GMT+9
 저장 시간 : 2022-05-23 11:43:10 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	STRING s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams " };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << s << "\r";
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:1124
2022-05-23 11:44:46 GMT+9
 저장 시간 : 2022-05-23 11:44:46 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include<format>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	string s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams " };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << format("{:^79}", s) << "\r";
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:1124
2022-05-23 11:44:54 GMT+9
 저장 시간 : 2022-05-23 11:44:54 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include<format>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	string s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams " };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << format("{:^79}", s) << "\r";
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:1124
2022-05-23 11:45:09 GMT+9
 저장 시간 : 2022-05-23 11:45:09 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include<format>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	string s{ "Son Heung-Min strikes heavy blow to Liverpool's quadruple dreams " };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << format("{:^79}", s) << "\r";
		this_thread::sleep_for(200ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:1086
2022-05-23 11:45:46 GMT+9
 저장 시간 : 2022-05-23 11:45:46 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include<format>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	string s{ "손흥민 프리미어리그 득점왕 " };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << format("{:^79}", s) << "\r";
		this_thread::sleep_for(200ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:1089
2022-05-23 11:46:16 GMT+9
 저장 시간 : 2022-05-23 11:46:16 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include<format>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	string s{ " 손흥민  프리미어리그  득점왕 " };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << format("{:^79}", s) << "\r";
		this_thread::sleep_for(200ms);
		rotate(s.begin(), s.begin() + 2, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:1087
2022-05-23 11:46:43 GMT+9
 저장 시간 : 2022-05-23 11:46:43 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<thread>
#include<format>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;



int main() {

	save("소스.cpp");
	string s{ " 손흥민  프리미어리그  득점왕 " };
	// [문제] 전광판으로 만들어라. - > 흘러가게 출력
	for (int i = 0; i < 10; ++i)
		cout << endl;
	while (true) {
		cout << format("{:^79}", s) << "\r";
		this_thread::sleep_for(200ms);
		rotate(s.begin(), s.end() - 2, s.end());
		
	}

}
파일 정보 : 소스.cpp, 크기:963
2022-05-23 11:51:40 GMT+9
 저장 시간 : 2022-05-23 11:51:40 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	// count와 count_if

	vector<int>v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10,3,3};
	
	//count 는 원하는 value의 개수를 센다. 
	//[문제] v에 3있나? 몇 개 있나? 
	cout << " 3의 개수 - " << count(v.begin(), v.end(), 3) << endl;
	
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1151
2022-05-23 11:53:46 GMT+9
 저장 시간 : 2022-05-23 11:53:46 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	// count와 count_if

	vector<int>v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10,3,3};
	
	//count 는 원하는 value의 개수를 센다. 
	//[문제] v에 3있나? 몇 개 있나? 
	cout << " 3의 개수 - " << count(v.begin(), v.end(), 3) << endl;
	
	//count_if 는 condition 에 맞는 원소의 수를 센다. 
	// [문제] v에 홀수는 몇 개 인가?
	cout << " 홀수의 개수 - " << count_if(v.begin(), v.end(), [](int n) {return n % 2; }) << endl;
	
	save("소스.cpp");

}
파일 정보 : 소스.cpp, 크기:1049
2022-05-23 11:59:39 GMT+9
 저장 시간 : 2022-05-23 11:59:39 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	// mismatch - 두 범위에서 달라지는 부분을 찾는다.

	string s1{ "1234567890" };
	string s2{ "123456779012345" };

	auto[s1에서달라지는위치,s2에서달라지는위치] = mismatch(s1.begin(), s1.end(),s2.begin()); 
	
	cout << *s1에서달라지는위치 << endl;
	cout << *s2에서달라지는위치 << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:986
2022-05-23 12:04:45 GMT+9
 저장 시간 : 2022-05-23 12:04:45 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// - Non-modifying sequence  읽기만 하는 
// - Modifying sequence  원소의 순서를 바꾸기도 하는  
// - Partitioning  갈라치기?
// - sorting 
//		nth_element
//		partial_sort
//		sort
//		stable_sort
// - Binary(on sorted ranges)
// 
// - 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	//search - 어떤 구간에서 원하는 구간을 찾는다.

	string s1{ "abcd thethexx thetye" };
	string s2{ "the" };

	auto p = search(s1.begin(), s1.end(), s2.begin(),s2.end());
	string res{ p,s1.end() };

	cout << res << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:638
2022-05-23 12:08:36 GMT+9
 저장 시간 : 2022-05-23 12:08:36 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	//copy 는 왜 mutating 알고리즘에 있나?
	vector<int>v{ 1,2,3 };

	copy(v.begin(), v.end(),ostream_iterator<int>(cout ,"\n"));

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:711
2022-05-23 12:09:20 GMT+9
 저장 시간 : 2022-05-23 12:09:20 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	//copy 는 왜 mutating 알고리즘에 있나?
	//-- 목적지가 자기 자신이 될수도 있기 때문이다.
	vector<int>v{ 1,2,3 };

	copy(v.begin(), v.end(),back_inserter(v));
	for (int n : v)
		cout << n << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:716
2022-05-23 12:10:10 GMT+9
 저장 시간 : 2022-05-23 12:10:10 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	//copy 는 왜 mutating 알고리즘에 있나?
	//-- 목적지가 자기 자신이 될수도 있기 때문이다.
	vector<int>v{ 1,2,3 };

	copy(v.begin(), v.end(),inserter(v,v.begin()));
	for (int n : v)
		cout << n << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:720
2022-05-23 12:10:18 GMT+9
 저장 시간 : 2022-05-23 12:10:18 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {

	//copy 는 왜 mutating 알고리즘에 있나?
	//-- 목적지가 자기 자신이 될수도 있기 때문이다.
	vector<int>v{ 1,2,3 };

	copy(v.begin(), v.end(),inserter(v,v.begin() + 1));
	for (int n : v)
		cout << n << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:716
2022-05-23 12:13:30 GMT+9
 저장 시간 : 2022-05-23 12:13:30 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {
	
	// erase-remove idiom
	vector<int> v{ 1,2,3,4,5,6 };
	
	//v에서 홀수를 제거하라
	v.erase(remove_if(v.begin(), v.end(), [](int n) {return n % 2; }), v.end());
	
	for (int n : v)
		cout << n << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:807
2022-05-23 12:16:50 GMT+9
 저장 시간 : 2022-05-23 12:16:50 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {
	
	// erase-remove idiom
	vector<int> v{ 1,2,3,4,5,6 };
	
	////v에서 홀수를 제거하라
	//v.erase(remove_if(v.begin(), v.end(), [](int n) {return n % 2; }), v.end());
	
	// C++20에서는 전역 erase함수를 제공한다.
	erase_if(v, [](int n) {return n % 2; });
	for (int n : v)
		cout << n << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:952
2022-05-23 12:18:44 GMT+9
 저장 시간 : 2022-05-23 12:18:44 GMT+9

//-----------------------------------------------------------------------------
//2022.5.23  월23                    월23수34                          (12주 1일)
//
//  알고리즘 
// 
// 6/15(수 15주 2일 ) - 기말시험 
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {
	
	// erase-remove idiom
	vector<int> v{ 1,2,3,4,5,6 };
	
	////v에서 홀수를 제거하라
	//v.erase(remove_if(v.begin(), v.end(), [](int n) {return n % 2; }), v.end());
	
	// C++20에서는 전역 erase함수를 제공한다.
	erase_if(v, [](int n) {return n % 2; });
	//STL에서 추구하는 이상과 정반대 의 함수,  디자인 패턴을 깨부수는 나쁜 함수
	//이유는 remove_if가 번거롭기 때문에 쓸수도있지만 거의안쓴다. 

	for (int n : v)
		cout << n << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1007
2022-05-25 11:31:53 GMT+9
 저장 시간 : 2022-05-25 11:31:53 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {
	
	// erase-remove idiom
	vector<int> v{ 1,2,3,4,5,6 };
	
	////v에서 홀수를 제거하라
	//v.erase(remove_if(v.begin(), v.end(), [](int n) {return n % 2; }), v.end());
	
	// C++20에서는 전역 erase함수를 제공한다.
	erase_if(v, [](int n) {return n % 2; });
	//STL에서 추구하는 이상과 정반대 의 함수,  디자인 패턴을 깨부수는 나쁜 함수
	//이유는 remove_if가 번거롭기 때문에 쓸수도있지만 거의안쓴다. 

	for (int n : v)
		cout << n << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:710
2022-05-25 11:36:03 GMT+9
 저장 시간 : 2022-05-25 11:36:03 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {
	
	vector v{ 1,2,3,4,5 };

	shift_left(v.begin(), v.end(), 1);

	for (int n : v)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:719
2022-05-25 11:40:26 GMT+9
 저장 시간 : 2022-05-25 11:40:26 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {
	
	vector v{ 1,2,3,4,5 };

	v.erase(shift_left(v.begin(), v.end(), 1));

	for (int n : v)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:727
2022-05-25 11:40:40 GMT+9
 저장 시간 : 2022-05-25 11:40:40 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

int main() {
	
	vector v{ 1,2,3,4,5 };

	v.erase(shift_left(v.begin(), v.end(), 1),v.end());

	for (int n : v)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:752
2022-05-25 11:44:00 GMT+9
 저장 시간 : 2022-05-25 11:44:00 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
#include<random>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() {

	vector<int> v(45);
	iota(v.begin(), v.end(), 1); // 숫자를 채워 넣는
	for (int n : v)
		cout << n << " ";
	cout << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:988
2022-05-25 11:46:52 GMT+9
 저장 시간 : 2022-05-25 11:46:52 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
#include<random>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

random_device rd; 
default_random_engine dre{ rd() };

int main() {

	vector<int> v(45);
	iota(v.begin(), v.end(), 1); // 숫자를 순서대로 채워 넣는
	for (int n : v)
		cout << n << " ";
	cout << endl;
	// 임의의 6개 숫자를 골라 출력한다.
	cout << " 이번 주에 사야할 숫자 " << endl;
	sample(v.begin(), v.end(), ostream_iterator<int>{cout, " "}, 6, dre);
	cout << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:988
2022-05-25 11:47:01 GMT+9
 저장 시간 : 2022-05-25 11:47:01 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
#include<random>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

random_device rd; 
default_random_engine dre{ rd() };

int main() {

	vector<int> v(45);
	iota(v.begin(), v.end(), 1); // 숫자를 순서대로 채워 넣는
	for (int n : v)
		cout << n << " ";
	cout << endl;
	// 임의의 6개 숫자를 골라 출력한다.
	cout << " 이번 주에 사야할 숫자 " << endl;
	sample(v.begin(), v.end(), ostream_iterator<int>{cout, " "}, 6, dre);
	cout << endl;
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:875
2022-05-25 11:51:04 GMT+9
 저장 시간 : 2022-05-25 11:51:04 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
#include<random>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

random_device rd; 
default_random_engine dre{ rd() };

int main() {

	vector<int> v{ 1,2,3,3,3,4,5,5,3 };
						//{ 1, 2, 3,4,5,3} unique를 한다면.. 예상

	v.erase(unique(v.begin(), v.end()),v.end());
	for (int n : v)
		cout << n << " ";
	cout << endl;
	
	save("소스.cpp");
}
파일 정보 : 소스.cpp, 크기:1092
2022-05-25 12:00:05 GMT+9
 저장 시간 : 2022-05-25 12:00:05 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
void print(const vector<int>&);

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v);
	save("소스.cpp");
}
void print(const vector<int>& v) 
{
	for (int n : v)
		cout << format("{:4}",n);
	cout << endl;
}
파일 정보 : 소스.cpp, 크기:1092
2022-05-25 12:00:16 GMT+9
 저장 시간 : 2022-05-25 12:00:16 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
void print(const vector<int>&);

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v);
	save("소스.cpp");
}
void print(const vector<int>& v) 
{
	for (int n : v)
		cout << format("{:4}",n);
	cout << endl;
}
파일 정보 : 소스.cpp, 크기:1092
2022-05-25 12:00:38 GMT+9
 저장 시간 : 2022-05-25 12:00:38 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
void print(const vector<int>&);

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v);
	save("소스.cpp");
}
void print(const vector<int>& v) 
{
	for (int n : v)
		cout << format("{:4}",n);
	cout << endl;
}
파일 정보 : 소스.cpp, 크기:1317
2022-05-25 12:06:15 GMT+9
 저장 시간 : 2022-05-25 12:06:15 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());
		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1420
2022-05-25 12:07:54 GMT+9
 저장 시간 : 2022-05-25 12:07:54 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());
		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		is_partitioned(v.begin(), v.end(), [](int a) {return a % 2 == 0; });
		print(v.begin(),v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1502
2022-05-25 12:12:37 GMT+9
 저장 시간 : 2022-05-25 12:12:37 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1981
2022-05-25 12:24:04 GMT+9
 저장 시간 : 2022-05-25 12:24:04 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 20, v.end());
		cout << " 20등까지 - " << endl;
		print(v.begin(), v.begin() + 20);
		cout << " 나머지 - " << endl;
		print(v.begin() + 20, v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1981
2022-05-25 12:24:51 GMT+9
 저장 시간 : 2022-05-25 12:24:51 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 20, v.end());
		cout << " 20등까지 - " << endl;
		print(v.begin(), v.begin() + 20);
		cout << " 나머지 - " << endl;
		print(v.begin() + 20, v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1920
2022-05-25 12:25:54 GMT+9
 저장 시간 : 2022-05-25 12:25:54 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 10등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 10, v.end());
		cout << " nth_ element 이후 - 10등 " << endl;
		print(v.begin(), v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:2256
2022-05-25 12:42:14 GMT+9
 저장 시간 : 2022-05-25 12:42:14 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 10등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 10, v.end());
		cout << " nth_ element 이후 - 10등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// partial_Sort - 필요한 순서까지만 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " partial_sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지만 정렬하라.
		partial_sort(v.begin(), v.begin() + 20, v.end());
		cout << " partial_sort 이후 - 20등 " << endl;
		print(v.begin(), v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:2256
2022-05-25 12:43:23 GMT+9
 저장 시간 : 2022-05-25 12:43:23 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 10등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 10, v.end());
		cout << " nth_ element 이후 - 10등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// partial_Sort - 필요한 순서까지만 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " partial_sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지만 정렬하라.
		partial_sort(v.begin(), v.begin() + 20, v.end());
		cout << " partial_sort 이후 - 20등 " << endl;
		print(v.begin(), v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:2256
2022-05-25 12:44:04 GMT+9
 저장 시간 : 2022-05-25 12:44:04 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
default_random_engine dre;
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 10등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 50, v.end());
		cout << " nth_ element 이후 - 10등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// partial_Sort - 필요한 순서까지만 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " partial_sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지만 정렬하라.
		partial_sort(v.begin(), v.begin() + 20, v.end());
		cout << " partial_sort 이후 - 20등 " << endl;
		print(v.begin(), v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:2283
2022-05-25 12:44:41 GMT+9
 저장 시간 : 2022-05-25 12:44:41 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 10등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 10, v.end());
		cout << " nth_ element 이후 - 10등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// partial_Sort - 필요한 순서까지만 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " partial_sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지만 정렬하라.
		partial_sort(v.begin(), v.begin() + 20, v.end());
		cout << " partial_sort 이후 - 20등 " << endl;
		print(v.begin(), v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:2568
2022-05-25 12:47:11 GMT+9
 저장 시간 : 2022-05-25 12:47:11 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort
//  stable_sort
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 10등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 10, v.end());
		cout << " nth_ element 이후 - 10등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// partial_Sort - 필요한 순서까지만 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " partial_sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지만 정렬하라.
		partial_sort(v.begin(), v.begin() + 20, v.end());
		cout << " partial_sort 이후 - 20등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// Sort - 전체 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 오름차순(ascending order)으로 정렬하라.
		sort(v.begin(),v.end());
		cout << " sort 이후 " << endl;
		print(v.begin(), v.end());

	}
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:2605
2022-05-25 12:50:13 GMT+9
 저장 시간 : 2022-05-25 12:50:13 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
template<class T>
void print(T b, T e)
{
	while (b != e) {
		cout << format("{:4}", *b);
		++b;
	}
	cout << endl;
}

int main() {
	// 1부터 100까지 값을 저장하는 vector
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	cout << "vector<int>의 원소들" << endl;
	print(v.begin(),v.end());

	{
		// partition 조건에 맞는 것과 아닌것을 분리 
		shuffle(v.begin(), v.end(), dre);
		cout << " partition 하기 전 " << endl;
		print(v.begin(),v.end());

		// [문제] 홀짝으로 나눠라 홀수와 짝수를 따로 출력하라
		auto it = partition(v.begin(), v.end(), [](int a) {return a % 2; });
		cout << " 홀수 - " << endl;
		print(v.begin(),it);
		cout << " 짝수 - " << endl;
		print(it, v.end());

	}
	{
		// nth_element 20등까지는 통과 ( 20등 까지는 순서는 상관 없다 )
		shuffle(v.begin(), v.end(), dre);
		cout << " nth_element 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 10등 까지와 나머지를 분리해서 출력하라  
		nth_element(v.begin(), v.begin() + 10, v.end());
		cout << " nth_ element 이후 - 10등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// partial_Sort - 필요한 순서까지만 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " partial_sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 20등 까지만 정렬하라.
		partial_sort(v.begin(), v.begin() + 20, v.end());
		cout << " partial_sort 이후 - 20등 " << endl;
		print(v.begin(), v.end());

	}
	{
		// Sort - 전체 정렬 
		shuffle(v.begin(), v.end(), dre);
		cout << " sort 하기 전 " << endl;
		print(v.begin(), v.end());

		// [문제] 오름차순(ascending order)으로 정렬하라.
		sort(v.begin(),v.end());
		cout << " sort 이후  " << endl;
		print(v.begin(), v.end());

	}
	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1327
2022-05-25 12:55:40 GMT+9
 저장 시간 : 2022-05-25 12:55:40 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 1000 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(20);

	for (const Dog& dog : v)
		dog.show();
	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1454
2022-05-25 12:57:31 GMT+9
 저장 시간 : 2022-05-25 12:57:31 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 1000 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(20);

	for (const Dog& dog : v)
		dog.show();

	// name 오름차순 정렬 후 출력
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.name < b.name; });

	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1452
2022-05-25 12:58:17 GMT+9
 저장 시간 : 2022-05-25 12:58:17 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 10 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(20);

	for (const Dog& dog : v)
		dog.show();

	// name 오름차순 정렬 후 출력
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.name < b.name; });

	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1452
2022-05-25 12:58:42 GMT+9
 저장 시간 : 2022-05-25 12:58:42 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 10 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(20);

	for (const Dog& dog : v)
		dog.show();

	// name 오름차순 정렬 후 출력
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.name > b.name; });

	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1514
2022-05-25 12:59:59 GMT+9
 저장 시간 : 2022-05-25 12:59:59 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 10 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(20);
	// name 오름차순 정렬 후 출력

	for (const Dog& dog : v)
		dog.show();

	cout << endl << endl;
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.n < b.n; });

	for (const Dog& dog : v)
		dog.show();

	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1695
2022-05-25 13:01:10 GMT+9
 저장 시간 : 2022-05-25 13:01:10 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 10 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(20);
	// name 오름차순 정렬 후 출력

	for (const Dog& dog : v)
		dog.show();

	cout << endl << endl;
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.name	 < b.name; });

	for (const Dog& dog : v)
		dog.show();
	cout << endl << endl;
	//  n오름차순 정렬
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.n < b.n; });

	for (const Dog& dog : v)
		dog.show();

	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1696
2022-05-25 13:02:02 GMT+9
 저장 시간 : 2022-05-25 13:02:02 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 10 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(100);
	// name 오름차순 정렬 후 출력

	for (const Dog& dog : v)
		dog.show();

	cout << endl << endl;
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.name	 < b.name; });

	for (const Dog& dog : v)
		dog.show();
	cout << endl << endl;
	//  n오름차순 정렬
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.n < b.n; });

	for (const Dog& dog : v)
		dog.show();

	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1703
2022-05-25 13:03:35 GMT+9
 저장 시간 : 2022-05-25 13:03:35 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 10 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(100);
	// name 오름차순 정렬 후 출력

	for (const Dog& dog : v)
		dog.show();

	cout << endl << endl;
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.name	 < b.name; });

	for (const Dog& dog : v)
		dog.show();
	cout << endl << endl;
	//  n오름차순 정렬
	stable_sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.n < b.n; });

	for (const Dog& dog : v)
		dog.show();

	//stable_sort란?

	save("소스.cpp");
}

파일 정보 : 소스.cpp, 크기:1899
2022-05-25 13:13:30 GMT+9
 저장 시간 : 2022-05-25 13:13:30 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<format>
#include<string>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidName{ 'A','Z' };
uniform_int_distribution uid{ 1, 10 };

struct Dog {
	string name;
	int n;
	
	Dog() {
		for (int i = 0; i < 5; ++i) 
			name += uidName(dre);
		n = uid(dre);
	}
	void show() const {
		cout << name << " - " << format("{:4d}", n) << endl;
	}
};

int main() {

	vector<Dog> v(100);
	// name 오름차순 정렬 후 출력

	for (const Dog& dog : v)
		dog.show();

	cout << endl << endl;
	sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.name	 < b.name; });

	for (const Dog& dog : v)
		dog.show();
	cout << endl << endl;
	//  n오름차순 정렬
	//stable_sort란?
	stable_sort(v.begin(), v.end(), [](const Dog& a, const Dog& b) {
		return a.n < b.n; });

	for (const Dog& dog : v)
		dog.show();


	save("소스.cpp");
}

//정렬되어있는 벡터가 array보다 훨씬 빠르다. 
//벡터가 훨씬 빠른 속도로 돌아간다. 
// 정렬해놓고 루프나, find를 사용하면 안된다. 
//Binary search operations (on sorted ranges) 사용 익숙하게

파일 정보 : 소스.cpp, 크기:933
2022-05-25 13:15:00 GMT+9
 저장 시간 : 2022-05-25 13:15:00 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() 
{
	vector v{ 1,2,3,4,5 };

	cout << distance(v.begin(), v.end()) << endl;
	cout << distance(v.end(), v.begin()) << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1055
2022-05-25 13:17:23 GMT+9
 저장 시간 : 2022-05-25 13:17:23 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

template<class Iter>
long long dist(Iter b, Iter e) {
	return e - b;
}

int main() 
{
	vector v{ 1,2,3,4,5 };

	// [문제] 템플릿 함수 dist를 작성하라 
	cout << dist(v.begin(), v.end()) << endl;
	cout << dist(v.end(), v.begin()) << endl;


	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1041
2022-05-25 13:18:27 GMT+9
 저장 시간 : 2022-05-25 13:18:27 GMT+9

//-----------------------------------------------------------------------------
//2022.5.25  수34                    월23수34                          (12주 2일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//  sorting 관련 알고리즘을 잘 살펴본다	- complexity 순서로 살펴본다. 
//  partition(sorting은 아님)O( n log n)
//  nth_element
//  partial_sort																
//  sort							n * log(n)
//  stable_sort				log( n* log(n))
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

template<class Iter>
long long dist(Iter b, Iter e) {
	return e - b;
}

int main() 
{
	vector v{ 1,2,3,4,5 };

	// [문제] 템플릿 함수 dist를 작성하라 
	cout << dist(v.begin(), v.end()) << endl;
	cout << dist(1, 100) << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:986
2022-06-06 10:46:10 GMT+9
 저장 시간 : 2022-06-06 10:46:10 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
}


int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(vector<char>::iterator{});
	f(deque<int>::const_iterator());

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1079
2022-06-06 10:47:05 GMT+9
 저장 시간 : 2022-06-06 10:47:05 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
}


int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(vector<char>::iterator{});
	f(deque<int>::const_iterator());

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1264
2022-06-06 10:51:47 GMT+9
 저장 시간 : 2022-06-06 10:51:47 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
	if (bidirectional_iterator<Iter>)
		cout << " 나는 bidirectional 반복자 입니다." << endl; //양방향
	if (forward_iterator<Iter>)
		cout << " 나는 forward 반복자 입니다." << endl;

}


int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(vector<char>::iterator{});
	f(deque<int>::const_iterator());

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1430
2022-06-06 10:55:02 GMT+9
 저장 시간 : 2022-06-06 10:55:02 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
	if (bidirectional_iterator<Iter>)
		cout << " 나는 bidirectional 반복자 입니다." << endl; //양방향
	if (forward_iterator<Iter>)
		cout << " 나는 forward 반복자 입니다." << endl; // 순방향 
	if (input_iterator<Iter>)
		cout << " 나는 input 반복자 입니다." << endl;
	//if (output_iterator<Iter>)
	//	cout << " 나는 ouput 반복자 입니다." << endl;
}

int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(vector<char>::iterator{});
	f(deque<int>::const_iterator());

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1438
2022-06-06 10:58:58 GMT+9
 저장 시간 : 2022-06-06 10:58:58 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<list>
#include<forward_list>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
	if (bidirectional_iterator<Iter>)
		cout << " 나는 bidirectional 반복자 입니다." << endl; //양방향
	if (forward_iterator<Iter>)
		cout << " 나는 forward 반복자 입니다." << endl; // 순방향 
	if (input_iterator<Iter>)
		cout << " 나는 input 반복자 입니다." << endl;
	//if (output_iterator<Iter>)
	//	cout << " 나는 ouput 반복자 입니다." << endl;
}

int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	
	f(list<STRING>::iterator());

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1443
2022-06-06 10:59:35 GMT+9
 저장 시간 : 2022-06-06 10:59:35 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<list>
#include<forward_list>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
	if (bidirectional_iterator<Iter>)
		cout << " 나는 bidirectional 반복자 입니다." << endl; //양방향
	if (forward_iterator<Iter>)
		cout << " 나는 forward 반복자 입니다." << endl; // 순방향 
	if (input_iterator<Iter>)
		cout << " 나는 input 반복자 입니다." << endl;
	//if (output_iterator<Iter>)
	//	cout << " 나는 ouput 반복자 입니다." << endl;
}

int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(forward_list<STRING>::iterator());

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1436
2022-06-06 10:59:55 GMT+9
 저장 시간 : 2022-06-06 10:59:55 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<list>
#include<forward_list>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
	if (bidirectional_iterator<Iter>)
		cout << " 나는 bidirectional 반복자 입니다." << endl; //양방향
	if (forward_iterator<Iter>)
		cout << " 나는 forward 반복자 입니다." << endl; // 순방향 
	if (input_iterator<Iter>)
		cout << " 나는 input 반복자 입니다." << endl;
	//if (output_iterator<Iter>)
	//	cout << " 나는 ouput 반복자 입니다." << endl;
}

int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(istream_iterator<char>{cin});
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1439
2022-06-06 11:00:28 GMT+9
 저장 시간 : 2022-06-06 11:00:28 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<list>
#include<forward_list>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
	if (bidirectional_iterator<Iter>)
		cout << " 나는 bidirectional 반복자 입니다." << endl; //양방향
	if (forward_iterator<Iter>)
		cout << " 나는 forward 반복자 입니다." << endl; // 순방향 
	if (input_iterator<Iter>)
		cout << " 나는 input 반복자 입니다." << endl;
	//if (output_iterator<Iter>)
	//	cout << " 나는 ouput 반복자 입니다." << endl;
}

int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(ostream_iterator<char>{cout});

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1579
2022-06-06 11:08:05 GMT+9
 저장 시간 : 2022-06-06 11:08:05 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<concepts>
#include<list>
#include<forward_list>
#include<vector>
#include<deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;
// 컨셉이란 조건이 주어질 때 내가 원하는 조건인지 확인할때 
// 어떤 함수가 있는데 c++ 20 부터는 어떤 함수를 클래스 뭐라고 쓰지않고 input_or_ouput으로 코딩가능
// constrained 알고리즘 제약알고리즘

template<input_or_output_iterator Iter>
void f(Iter iter)
{
	if (contiguous_iterator<Iter>)
		cout << " 나는 contiguous 반복자 입니다. " << endl;
	if (random_access_iterator<Iter>)
		cout << " 나는 random-access 반복자 입니다." << endl;
	if (bidirectional_iterator<Iter>)
		cout << " 나는 bidirectional 반복자 입니다." << endl; //양방향
	if (forward_iterator<Iter>)
		cout << " 나는 forward 반복자 입니다." << endl; // 순방향 
	if (input_iterator<Iter>)
		cout << " 나는 input 반복자 입니다." << endl;
	//if (output_iterator<Iter>)
	//	cout << " 나는 ouput 반복자 입니다." << endl;
}

int main() 
{
	//[ 문제 ] 함수 f는 반복자를 인자로 받아 어떤 종류인지 화면에 출력한다. 
	f(ostream_iterator<char>{cout});

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:676
2022-06-06 11:10:06 GMT+9
 저장 시간 : 2022-06-06 11:10:06 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() 
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };
	sort(begin(a), end(a)); //예전 해결방법 


	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:729
2022-06-06 11:10:31 GMT+9
 저장 시간 : 2022-06-06 11:10:31 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() 
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };
	sort(begin(a), end(a)); //예전 해결방법 

	for (int n : a)
		cout << n << " ";
	cout << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:804
2022-06-06 11:15:48 GMT+9
 저장 시간 : 2022-06-06 11:15:48 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<ranges>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main() 
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };

	ranges::sort(a); // 컴파일 하기 이전에 알수 있다. 제약사항에 맞지 않으니까  
	

	for (int n : a)
		cout << n << " ";
	cout << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:905
2022-06-06 11:35:52 GMT+9
 저장 시간 : 2022-06-06 11:35:52 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<ranges>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


template<class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b; 
	b = temp;
}

int main() 
{
	// 질문 template specialization과 concept의 차이점?
	// 템플릿 특수화 - 특정 타입에 대한 정의를 프로그래머가 제공
	int a = 1, b = 2;
	change(a, b);
	cout << a << " , " << b << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:937
2022-06-06 11:36:26 GMT+9
 저장 시간 : 2022-06-06 11:36:26 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<ranges>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


template<class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b; 
	b = temp;
}

int main() 
{
	// 질문 template specialization과 concept의 차이점?
	// 템플릿 특수화 - 특정 타입에 대한 정의를 프로그래머가 제공
	int a = 1, b = 2;
	int* p = &a;
	int* q = &b;
	change(p, q);
	cout << a << " , " << b << endl;

	save("소스.cpp");
}




파일 정보 : 소스.cpp, 크기:1032
2022-06-06 11:39:18 GMT+9
 저장 시간 : 2022-06-06 11:39:18 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//  알고리즘 - 어떤 것이 있나 다 살펴본다 - C++reference
// 
//   
// 6/1 학교휴강
// 6/6(월)					- 수업
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<ranges>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

template<class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

template<>
void change<int*>(int*& a, int*& b)
{
	int Temp{ *a };
	*a = *b;
	*b = Temp;
}

int main() 
{
	// 질문 template specialization과 concept의 차이점?
	// 템플릿 특수화 - 특정 타입에 대한 정의를 프로그래머가 제공
	int a = 1, b = 2;
	int* p = &a;
	int* q = &b;
	change(p, q);
	cout << a << " , " << b << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1110
2022-06-06 12:10:46 GMT+9
 저장 시간 : 2022-06-06 12:10:46 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);
	}

	void show() const {
		cout << format("{:6}", num) << name << endl;
	}
};

int main() 
{
	vector<Dog> v(100);
	
	for (const Dog& dog : v)
		dog.show();
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1112
2022-06-06 12:11:41 GMT+9
 저장 시간 : 2022-06-06 12:11:41 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);
	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}
};

int main() 
{
	vector<Dog> v(100);
	
	for (const Dog& dog : v)
		dog.show();
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1410
2022-06-06 12:21:04 GMT+9
 저장 시간 : 2022-06-06 12:21:04 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);
	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 num 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, [](const Dog& a, const Dog& b) {
		return a.getNum() > b.getNum(); });

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1410
2022-06-06 12:21:15 GMT+9
 저장 시간 : 2022-06-06 12:21:15 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);
	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 num 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, [](const Dog& a, const Dog& b) {
		return a.getNum() < b.getNum(); });

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1357
2022-06-06 12:26:11 GMT+9
 저장 시간 : 2022-06-06 12:26:11 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);
	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 num 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, {},&Dog::getNum );

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1358
2022-06-06 12:26:23 GMT+9
 저장 시간 : 2022-06-06 12:26:23 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);
	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 num 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, {},&Dog::getName );

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1370
2022-06-06 12:29:04 GMT+9
 저장 시간 : 2022-06-06 12:29:04 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);
	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 num 기준 내림차순(dscending order)으로 정렬하라 
	ranges::sort(v, greater<int>{}, & Dog::getNum);

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1422
2022-06-06 12:34:07 GMT+9
 저장 시간 : 2022-06-06 12:34:07 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,30 };

class Dog {
	string name;
	int num;
	int count;
public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);

	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
	int getLen() const { return name.size(); }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 이름 길이 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, {}, & Dog::getLen);

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1423
2022-06-06 12:34:49 GMT+9
 저장 시간 : 2022-06-06 12:34:49 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,100 };

class Dog {
	string name;
	int num;
	int count;
public:
	Dog() {
		num = uidNum(dre);
		for (int i = 0; i < uidLen(dre); ++i)
			name += uidName(dre);

	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
	int getLen() const { return name.size(); }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 이름 길이 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, {}, & Dog::getLen);

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1436
2022-06-06 12:36:01 GMT+9
 저장 시간 : 2022-06-06 12:36:01 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,100 };

class Dog {
	string name;
	int num;
	int count;
public:
	Dog() {
		num = uidNum(dre);
		int x = uidLen(dre);
		for (int i = 0; i <x; ++i)
			name += uidName(dre);

	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
	int getLen() const { return name.size(); }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 이름 길이 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, {}, & Dog::getLen);

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1435
2022-06-06 12:36:26 GMT+9
 저장 시간 : 2022-06-06 12:36:26 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,70 };

class Dog {
	string name;
	int num;
	int count;
public:
	Dog() {
		num = uidNum(dre);
		int x = uidLen(dre);
		for (int i = 0; i <x; ++i)
			name += uidName(dre);

	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
	int getLen() const { return name.size(); }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 이름 길이 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, {}, & Dog::getLen);

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1435
2022-06-06 12:39:01 GMT+9
 저장 시간 : 2022-06-06 12:39:01 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<random>
#include<vector>
#include<string>
#include<format>	
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//[새로운 내용] constrained algorithm 은 대부분 projection을 지원 

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution<int> uidNum{ 1,1000 };
uniform_int_distribution<int>uidLen{ 3,70 };

class Dog {
	string name;
	int num;
	int count;
public:
	Dog() {
		num = uidNum(dre);
		int x = uidLen(dre);
		for (int i = 0; i <x; ++i)
			name += uidName(dre);

	}

	void show() const {
		cout << format("{:4}  ", num) << name << endl;
	}

	string getName()const { return name; }
	int getNum()const { return num; }
	int getLen() const { return name.size(); }
};

int main()
{
	vector<Dog> v(100);

	// C++ 20 constrained algortihm 으로 정렬
	// [문제] v를 이름 길이 기준 오름차순(ascending order)으로 정렬하라 
	ranges::sort(v, {}, & Dog::getLen);

	for (const Dog& dog : v)
		dog.show();

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:882
2022-06-06 12:55:11 GMT+9
 저장 시간 : 2022-06-06 12:55:11 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] range a 에서 홀수만 출력하라. 
	//for (int n : a) 이 for루프를 range for 라고불린다.
	//	if (n % 2)
	//		cout << n << " ";
	//cout << endl; 이렇게 하지말아라
	auto 홀수 = [](int n) {return n % 2; };
	for (int n : a | views::filter(홀수))
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:834
2022-06-06 12:57:19 GMT+9
 저장 시간 : 2022-06-06 12:57:19 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] range a 에서 홀수만 골라 제곱하여 출력하라. 

	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };
	for (int n : a | views::filter(홀수) | views::transform(제곱))
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:851
2022-06-06 12:58:30 GMT+9
 저장 시간 : 2022-06-06 12:58:30 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] range a 에서 홀수만 골라 제곱하여 출력하라. 

	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };
	for (int n : a | views::filter(홀수) | views::transform(제곱) | views::reverse)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:859
2022-06-06 12:58:50 GMT+9
 저장 시간 : 2022-06-06 12:58:50 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] range a 에서 홀수만 골라 제곱하여 거꾸로  출력하라. 

	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };
	for (int n : a | views::filter(홀수) | views::transform(제곱) | views::reverse)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:903
2022-06-06 13:02:32 GMT+9
 저장 시간 : 2022-06-06 13:02:32 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] 1부터 시작하는 자연수에서 홀수만 골라 제곱하여  출력하라. 
	// 100개만 출력하라.

	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };
	for (int n : views::iota(1) | views::filter(홀수) | views::transform(제곱) | views::take(100))
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:920
2022-06-06 13:03:28 GMT+9
 저장 시간 : 2022-06-06 13:03:28 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] 1부터 시작하는 자연수에서 홀수만 골라 제곱하여  출력하라. 
	// 100개만 출력하라.

	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };
	for (int n : views::iota(1) | views::filter(홀수) | views::transform(제곱) | views::take(1000))
		cout << format("{:20}",n) << " ";
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:920
2022-06-06 13:03:46 GMT+9
 저장 시간 : 2022-06-06 13:03:46 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] 1부터 시작하는 자연수에서 홀수만 골라 제곱하여  출력하라. 
	// 100개만 출력하라.

	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };
	for (int n : views::iota(1) | views::filter(홀수) | views::transform(제곱) | views::take(1000))
		cout << format("{:15}",n) << " ";
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:913
2022-06-06 13:04:02 GMT+9
 저장 시간 : 2022-06-06 13:04:02 GMT+9

//-----------------------------------------------------------------------------
//2022.6.6  월23                    월23수34                          (14주 1일)
//
//	Range/View
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<format>	
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;


int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };
	
	//[ 문제 ] 1부터 시작하는 자연수에서 홀수만 골라 제곱하여  출력하라. 
	// 100개만 출력하라.

	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };
	for (int n : views::iota(1) | views::filter(홀수) | views::transform(제곱) | views::take(1000))
		cout << format("{:20}",n);
	cout << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:801
2022-06-08 11:59:21 GMT+9
 저장 시간 : 2022-06-08 11:59:21 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 

//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.

int main()
{
	ifstream in{ "단어들.txt" };
	string str;
	vector<string> v;
	while (in >> str) {
		v.push_back(str);
	}
	cout << v.size() << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:788
2022-06-08 12:00:52 GMT+9
 저장 시간 : 2022-06-08 12:00:52 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 

//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.

int main()
{
	ifstream in{ "단어들.txt" };
	string s;
	int cnt{};
	while (in >> s) {
		cnt++;
	}
	cout << "단어 수 - " << cnt << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:786
2022-06-08 12:02:02 GMT+9
 저장 시간 : 2022-06-08 12:02:02 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 

//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.

int main()
{
	ifstream in{ "실험.txt" };
	string s;
	int cnt{};
	while (in >> s) {
		cnt++;
	}
	cout << "단어 수 - " << cnt << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:795
2022-06-08 12:03:06 GMT+9
 저장 시간 : 2022-06-08 12:03:06 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 

//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.

int main()
{
	ifstream in{ "실험.txt" };
	string s;
	int cnt{};
	while (!in ) {
		in >> s;
		cnt++;
	}
	cout << "단어 수 - " << cnt << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:801
2022-06-08 12:03:19 GMT+9
 저장 시간 : 2022-06-08 12:03:19 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 

//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.

int main()
{
	ifstream in{ "실험.txt" };
	string s;
	int cnt{};
	while (!in.eof() ) {
		in >> s;
		cnt++;
	}
	cout << "단어 수 - " << cnt << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:801
2022-06-08 12:05:47 GMT+9
 저장 시간 : 2022-06-08 12:05:47 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 

//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.

int main()
{
	ifstream in{ "단어들.txt" };
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1115
2022-06-08 12:11:54 GMT+9
 저장 시간 : 2022-06-08 12:11:54 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	// [문제] 정렬되어 있나? 중복된 단어는 없나? 
	cout << boolalpha;
	cout << "정렬 ? " << is_sorted(v.begin(), v.end()/*less<string>*/) << endl;; //정렬되어 있는지 확인하는 알고리즘 함수 
	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1270
2022-06-08 12:13:16 GMT+9
 저장 시간 : 2022-06-08 12:13:16 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	// [문제] 정렬되어 있나? 중복된 단어는 없나? 
	cout << boolalpha;
	cout << "정렬 ? " << is_sorted(v.begin(), v.end()/*less<string>*/) << endl;; //정렬되어 있는지 확인하는 알고리즘 함수 
	
	auto p = unique(v.begin(), v.end());
	if (p == v.end()) {
		cout << "중복된 단어 없음" << endl;
	}
	else
		cout << "중복된 단어 없음" << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1270
2022-06-08 12:13:28 GMT+9
 저장 시간 : 2022-06-08 12:13:28 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	// [문제] 정렬되어 있나? 중복된 단어는 없나? 
	cout << boolalpha;
	cout << "정렬 ? " << is_sorted(v.begin(), v.end()/*less<string>*/) << endl;; //정렬되어 있는지 확인하는 알고리즘 함수 
	
	auto p = unique(v.begin(), v.end());
	if (p == v.end()) {
		cout << "중복된 단어 없음" << endl;
	}
	else
		cout << "중복된 단어 있음" << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1225
2022-06-08 12:14:53 GMT+9
 저장 시간 : 2022-06-08 12:14:53 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	// [문제] 정렬되어 있나? 중복된 단어는 없나? 
	cout << boolalpha;
	cout << "정렬 ? " << is_sorted(v.begin(), v.end()/*less<string>*/) << endl;; //정렬되어 있는지 확인하는 알고리즘 함수 
	
	set<string> s{ v.begin(),v.end() };
	if (v.size() == s.size())
		cout << "중복된 단어 없음" << endl;

	save("소스.cpp");
}



파일 정보 : 소스.cpp, 크기:1189
2022-06-08 12:18:44 GMT+9
 저장 시간 : 2022-06-08 12:18:44 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		auto p = find(v.begin(), v.end(), word);
		cout << *p << endl;
		
	}
}



파일 정보 : 소스.cpp, 크기:1207
2022-06-08 12:21:06 GMT+9
 저장 시간 : 2022-06-08 12:21:06 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		set<string> s{ v.begin(),v.end() };
		auto p= s.find(word);
		cout << *p << endl;

	}
}



파일 정보 : 소스.cpp, 크기:1277
2022-06-08 12:21:43 GMT+9
 저장 시간 : 2022-06-08 12:21:43 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		set<string> s{ v.begin(),v.end() };
		auto p= s.find(word);
		if (p == s.end())
			cout << "찾으시는 단어가 없습니다/" << endl;
		cout << *p << endl;

	}
}



파일 정보 : 소스.cpp, 크기:1286
2022-06-08 12:21:59 GMT+9
 저장 시간 : 2022-06-08 12:21:59 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;
	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		set<string> s{ v.begin(),v.end() };
		auto p= s.find(word);
		if (p == s.end())
			cout << "찾으시는 단어가 없습니다/" << endl;
		else
			cout << *p << endl;

	}
}



파일 정보 : 소스.cpp, 크기:1515
2022-06-08 12:33:50 GMT+9
 저장 시간 : 2022-06-08 12:33:50 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		set<string> s{ v.begin(),v.end() };
		auto p= s.find(word);
		if (p == s.end())
			cout << "찾으시는 단어가 없습니다/" << endl;
		else
			cout << *p << endl;

	}
}



파일 정보 : 소스.cpp, 크기:1570
2022-06-08 12:36:45 GMT+9
 저장 시간 : 2022-06-08 12:36:45 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			continue;
		}
		// 애너그램을 찾는다. 
		

	}
}



파일 정보 : 소스.cpp, 크기:1763
2022-06-08 12:42:19 GMT+9
 저장 시간 : 2022-06-08 12:42:19 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		do {
			cout << word << endl;
		}while(next_permutation(word.begin(), word.end()));

	}
}



파일 정보 : 소스.cpp, 크기:1869
2022-06-08 12:44:42 GMT+9
 저장 시간 : 2022-06-08 12:44:42 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		do {
			cout << word << endl;
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?

	}
}



파일 정보 : 소스.cpp, 크기:1966
2022-06-08 12:46:41 GMT+9
 저장 시간 : 2022-06-08 12:46:41 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << " word의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		
		do {
			if (binary_search(v.begin(), v.end(), word))
				cout << word;
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:1972
2022-06-08 12:47:13 GMT+9
 저장 시간 : 2022-06-08 12:47:13 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << " word의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		
		do {
			if (binary_search(v.begin(), v.end(), word))
				cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:1975
2022-06-08 12:47:54 GMT+9
 저장 시간 : 2022-06-08 12:47:54 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << word <<" 의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		
		do {
			if (binary_search(v.begin(), v.end(), word))
				cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:2005
2022-06-08 12:51:38 GMT+9
 저장 시간 : 2022-06-08 12:51:38 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << word <<" 의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		
		do {
			cout << word << "\r";
			//if (binary_search(v.begin(), v.end(), word))
				//cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:2018
2022-06-08 12:52:23 GMT+9
 저장 시간 : 2022-06-08 12:52:23 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << word <<" 의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		cout << endl;
		do {
			cout << word << "\r";
			//if (binary_search(v.begin(), v.end(), word))
				//cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:2018
2022-06-08 12:52:43 GMT+9
 저장 시간 : 2022-06-08 12:52:43 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << word <<" 의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		cout << endl;
		do {
			cout << word << endl;
			//if (binary_search(v.begin(), v.end(), word))
				//cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:2018
2022-06-08 12:53:24 GMT+9
 저장 시간 : 2022-06-08 12:53:24 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << word <<" 의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		cout << endl;
		do {
			cout << word << "\r";
			//if (binary_search(v.begin(), v.end(), word))
				//cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:2018
2022-06-08 12:53:53 GMT+9
 저장 시간 : 2022-06-08 12:53:53 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << word <<" 의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		cout << endl;
		do {
			cout << word << endl;
			//if (binary_search(v.begin(), v.end(), word))
				//cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:2161
2022-06-08 13:01:41 GMT+9
 저장 시간 : 2022-06-08 13:01:41 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//battle - tablet 이런관계가 애너그램 관계 


int main()
{
	save("소스.cpp");
	//[문제] e-class에서 "단어들.txt" 를 읽어 몇 단어인지 출력한다.
	ifstream in{ "단어들.txt" };			// 단어 수 369882개 가져야 할 의문점 , 정렬은 되어있는가 -  중복되는 단어는 없는가? 
	vector<string> v{ istream_iterator<string>{in},{} }; // << 정의
	cout << " 단어 수 - " << v.size() << endl;

	//[문제] 가장 길이가 긴 단어는?
	auto p = max_element(v.begin(), v.end(), [](const string a, const string b) {
		return a.length() < b.length();  });
	cout << "길이가 가장 긴 단어 - " <<p->length()<<" , " << *p << endl;
	// 길이가 가장 긴 단어 - 31 , dichlorodiphenyltrichloroethane

	// 길이 20글자 단어 
	cout << " 20 글자 - "<< *find_if(v.begin(), v.end(), [](const string& s) {
		return s.length() == 20;
		}) << endl;
	//[ 문제 ] 사용자가 입력한 단어인 애너그램을 출력하라
	// 1. 사용자가 입력한 단어가 v에 있는지 확인하라 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
		if (!binary_search(v.begin(), v.end(), word)) {
			cout << word << " 는 없는 단어 입니다." << endl;
			//continue;
		}
		// 애너그램을 찾는다. 
		// 입력한 단어의 가능한 순열(permutation)을 찾아 단어에 있나 검사한 후 
		// 있다면 화면에 출력한다. 
		cout << word <<" 의 anergram들 - ";
		sort(word.begin(), word.end());//sort를 해두고 찾아야 순열이 전부 출력될 것 
		cout << endl;
		do {
			cout << word << endl;
			//if (binary_search(v.begin(), v.end(), word))
				//cout << word <<" ";
		}while(next_permutation(word.begin(), word.end())); // 상태를 기억하는 함수 ?
		cout << endl;
	}
}



파일 정보 : 소스.cpp, 크기:1002
2022-06-08 13:17:25 GMT+9
 저장 시간 : 2022-06-08 13:17:25 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	for (WP words : v | views::drop(10'0000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;
}



파일 정보 : 소스.cpp, 크기:1001
2022-06-08 13:17:40 GMT+9
 저장 시간 : 2022-06-08 13:17:40 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	for (WP words : v | views::drop(10'0000)
		| views::take(30))
		cout << words.first << " --- " << words.second << endl;
}



파일 정보 : 소스.cpp, 크기:1033
2022-06-08 13:18:38 GMT+9
 저장 시간 : 2022-06-08 13:18:38 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);
	for (WP words : v | views::drop(1000)
		| views::take(50))
		cout << words.first << " --- " << words.second << endl;
}



파일 정보 : 소스.cpp, 크기:1033
2022-06-11 15:31:14 GMT+9
 저장 시간 : 2022-06-11 15:31:14 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);
	for (WP words : v | views::drop(1000)
		| views::take(50))
		cout << words.first << " --- " << words.second << endl;
}



파일 정보 : 소스.cpp, 크기:1033
2022-06-13 10:32:58 GMT+9
 저장 시간 : 2022-06-13 10:32:58 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{
	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);
	for (WP words : v | views::drop(1000)
		| views::take(50))
		cout << words.first << " --- " << words.second << endl;
}



파일 정보 : 소스.cpp, 크기:1036
2022-06-13 10:34:23 GMT+9
 저장 시간 : 2022-06-13 10:34:23 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{
	
	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);
	for (WP words : v | views::drop(1000)
		| views::take(50))
		cout << words.first << " --- " << words.second << endl;
}



파일 정보 : 소스.cpp, 크기:1055
2022-06-13 10:37:22 GMT+9
 저장 시간 : 2022-06-13 10:37:22 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	for (const WP& words : v | views::drop(10000)
											| views::take(100))
		cout << words.first << " --- " << words.second << endl;
}



파일 정보 : 소스.cpp, 크기:1222
2022-06-13 10:42:47 GMT+9
 저장 시간 : 2022-06-13 10:42:47 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	for (WP words : v | views::drop(15'0000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		
	}

}



파일 정보 : 소스.cpp, 크기:1348
2022-06-13 10:48:42 GMT+9
 저장 시간 : 2022-06-13 10:48:42 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		do {
			sort(word.begin(), word.end());
		} while (next_permutation(word.begin(), word.end()));
	}
	
}



파일 정보 : 소스.cpp, 크기:1870
2022-06-13 11:05:55 GMT+9
 저장 시간 : 2022-06-13 11:05:55 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		// 입력한 단어가 사전에 있나?
		// 사전에 있는 단어라면
		//	단어를 정렬한다.
		//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
		//  WP의 second를 출력한다. 
		WP wp(word);
		auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
		
		if (하한 == 상한)
			cout << word << " 는 사전에 없는 단어 입니다. " << endl;
		else if (상한 - 하한 == 1)
			cout << word << " 애너그램이 없는 단어 입니다. " << endl;
		else {
			cout << word << " - ";
			for (auto i = 하한; i < 상한; ++i)
				cout << i->second << " ";
			cout << endl;
		}
	}
	
}



파일 정보 : 소스.cpp, 크기:1870
2022-06-13 11:06:06 GMT+9
 저장 시간 : 2022-06-13 11:06:06 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		// 입력한 단어가 사전에 있나?
		// 사전에 있는 단어라면
		//	단어를 정렬한다.
		//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
		//  WP의 second를 출력한다. 
		WP wp(word);
		auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
		
		if (하한 == 상한)
			cout << word << " 는 사전에 없는 단어 입니다. " << endl;
		else if (상한 - 하한 == 1)
			cout << word << " 애너그램이 없는 단어 입니다. " << endl;
		else {
			cout << word << " - ";
			for (auto i = 하한; i < 상한; ++i)
				cout << i->second << " ";
			cout << endl;
		}
	}
	
}



파일 정보 : 소스.cpp, 크기:1870
2022-06-13 11:06:54 GMT+9
 저장 시간 : 2022-06-13 11:06:54 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		// 입력한 단어가 사전에 있나?
		// 사전에 있는 단어라면
		//	단어를 정렬한다.
		//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
		//  WP의 second를 출력한다. 
		WP wp(word);
		auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
		
		if (하한 == 상한)
			cout << word << " 는 사전에 없는 단어 입니다. " << endl;
		else if (상한 - 하한 == 1)
			cout << word << " 애너그램이 없는 단어 입니다. " << endl;
		else {
			cout << word << " - ";
			for (auto i = 하한; i < 상한; ++i)
				cout << i->second << " ";
			cout << endl;
		}
	}
	
}



파일 정보 : 소스.cpp, 크기:1872
2022-06-13 11:08:55 GMT+9
 저장 시간 : 2022-06-13 11:08:55 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		// 입력한 단어가 사전에 있나?
		// 사전에 있는 단어라면
		//	단어를 정렬한다.
		//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
		//  WP의 second를 출력한다. 
		WP wp(word);
		auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
		
		if (하한 == 상한)
			cout << word << " 는 사전에 없는 단어 입니다. " << endl;
		else if (상한 - 하한 == 1)
			cout << word << " 애너그램이 없는 단어 입니다. " << endl;
		else {
			cout << word << " - ";
			for (auto i = 하한; i < 상한; ++i)
				cout << i->second << " ";

			cout << endl;
		}
	}
	
}



파일 정보 : 소스.cpp, 크기:2042
2022-06-13 11:12:16 GMT+9
 저장 시간 : 2022-06-13 11:12:16 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		// 입력한 단어가 사전에 있나?
		// 사전에 있는 단어라면
		//	단어를 정렬한다.
		//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
		//  WP의 second를 출력한다. 
		WP wp(word);
		auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
		
		if (하한 == 상한)
			cout << word << " 는 사전에 없는 단어 입니다. " << endl;
		else if (상한 - 하한 == 1)
			cout << word << " 애너그램이 없는 단어 입니다. " << endl;
		else {
			cout << word << " -- ";
			for (auto i = 하한; i < 상한; ++i)
				cout << i->second << " ";

			cout << endl;
		}
	}	
	for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.

	
}



파일 정보 : 소스.cpp, 크기:2185
2022-06-13 11:19:47 GMT+9
 저장 시간 : 2022-06-13 11:19:47 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		// 입력한 단어가 사전에 있나?
		// 사전에 있는 단어라면
		//	단어를 정렬한다.
		//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
		//  WP의 second를 출력한다. 
		WP wp(word);
		auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
		
		if (하한 == 상한)
			cout << word << " 는 사전에 없는 단어 입니다. " << endl;
		else if (상한 - 하한 == 1)
			cout << word << " 애너그램이 없는 단어 입니다. " << endl;
		else {
			cout << word << " -- ";
			for (auto i = 하한; i < 상한; ++i)
				cout << i->second << " ";
			cout << endl;
		}
	}	
	/*for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;*/
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	//while (true) {
	//}
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	
}



파일 정보 : 소스.cpp, 크기:2184
2022-06-13 11:20:15 GMT+9
 저장 시간 : 2022-06-13 11:20:15 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt" };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	while (true) {
		string word;
		cout << " 찾을 단어는 ? ";
		cin >> word;
		// 입력한 단어가 사전에 있나?
		// 사전에 있는 단어라면
		//	단어를 정렬한다.
		//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
		//  WP의 second를 출력한다. 
		WP wp(word);
		auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
		
		if (하한 == 상한)
			cout << word << " 는 사전에 없는 단어 입니다. " << endl;
		else if (상한 - 하한 == 1)
			cout << word << " 애너그램이 없는 단어 입니다. " << endl;
		else {
			cout << word << " -- ";
			for (auto i = 하한; i < 상한; ++i)
				cout << i->first << " ";
			cout << endl;
		}
	}	
	/*for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;*/
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	//while (true) {
	//}
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	
}



파일 정보 : 소스.cpp, 크기:2657
2022-06-13 11:45:36 GMT+9
 저장 시간 : 2022-06-13 11:45:36 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();

	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
		int cnt{};
		cout << "[ " << ++cnt << " ] -> ";
		for (auto p = i; i < j; ++i)
			cout << p->second << " ";
		cout << endl;
	}	
	
}



파일 정보 : 소스.cpp, 크기:2669
2022-06-13 11:45:47 GMT+9
 저장 시간 : 2022-06-13 11:45:47 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();

	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
		int cnt{};
		cout << "[ " << ++cnt << " ] -> ";
		for (auto p = i; i < j; ++i)
			cout << p->second << " ";
		cout << endl;

		b = j;
	}	
	
}



파일 정보 : 소스.cpp, 크기:2669
2022-06-13 11:46:11 GMT+9
 저장 시간 : 2022-06-13 11:46:11 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();

	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
		int cnt{};
		cout << "[ " << ++cnt << " ] -> ";
		for (auto p = i; p < j; ++p)
			cout << p->second << " ";
		cout << endl;

		b = j;
	}	
	
}



파일 정보 : 소스.cpp, 크기:2669
2022-06-13 11:46:38 GMT+9
 저장 시간 : 2022-06-13 11:46:38 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
	
		cout << "[ " << ++cnt << " ] -> ";
		for (auto p = i; p < j; ++p)
			cout << p->second << " ";
		cout << endl;

		b = j;
	}	
	
}



파일 정보 : 소스.cpp, 크기:2669
2022-06-13 11:47:47 GMT+9
 저장 시간 : 2022-06-13 11:47:47 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(1000)
		| views::take(100))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
	
		cout << "[ " << ++cnt << " ] -> ";
		for (auto p = i; p < j; ++p)
			cout << p->second << " ";
		cout << endl;

		b = j;
	}	
	
}



파일 정보 : 소스.cpp, 크기:2706
2022-06-13 11:49:38 GMT+9
 저장 시간 : 2022-06-13 11:49:38 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	ofstream out{ "애너그램쌍.txt" };

	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
	
		out << "[ " << ++cnt << " ] -> ";
		for (auto p = i; p < j; ++p)
			out << p->second << " ";
		out << endl;

		b = j;
	}	
	
}



파일 정보 : 소스.cpp, 크기:2892
2022-06-13 11:58:54 GMT+9
 저장 시간 : 2022-06-13 11:58:54 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?

	//[문제 ] 전체 anagram 쌍을 개수 기준 내림차순으로 출력하라. 

	auto b = v.cbegin();
	int cnt{};
	ofstream out{ "애너그램쌍.txt" };

	vector<WP> v2;


	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
	
		for (auto p = i; p < j; ++p)
			v2.push_back(p->second);
		b = j;
	}	
	sort(v2.begin(), v2.end(), [](const WP& a, const WP& b) {return a.second.size() < b.second.size(); });
	for (WP a : v2)
		cout << a.second << endl;
	
}



파일 정보 : 소스.cpp, 크기:2692
2022-06-13 12:00:46 GMT+9
 저장 시간 : 2022-06-13 12:00:46 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string, string> { //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;

	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	ofstream out{ "애너그램쌍.txt" };

	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 

		out << "[ " << ++cnt << " ] -> ";
		for (auto p = i; p < j; ++p)
			out << p->second << " ";
		out << endl;

		b = j;
	}

}파일 정보 : 소스.cpp, 크기:2701
2022-06-13 12:01:10 GMT+9
 저장 시간 : 2022-06-13 12:01:10 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string, string> { //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;

	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	ofstream out{ "애너그램쌍.txt" };

	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 

		out << "[ " << ++cnt << " ] -> ";
		for (auto p = i; p < j; ++p)
			out <<" -> " << p->second << " ";
		out << endl;

		b = j;
	}

}파일 정보 : 소스.cpp, 크기:3072
2022-06-13 12:09:01 GMT+9
 저장 시간 : 2022-06-13 12:09:01 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<list>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	
	vector<list<string>> vls;



	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
		list<string>ls;

		for (auto p = i; p < j; ++p)
			ls.push_back(p->second);
		
		vls.push_back(ls);

		b = j;
	}	
	
	//vector<list<string>> 정렬
	// 개수순 
	sort(vls.begin(), vls.end(), [](const list<string>& a, const list<string>& b) {
		return a.size() > b.size();
		});
	cout << "가장 개수가 많은 쌍 - " << vls[0].size() << endl;
	//앞에서 부터 10개 출력

	for (const list<string>& ls : vls | views::take(10)) {
		for (const string& s : ls )
			cout << s << " ";
	}

}파일 정보 : 소스.cpp, 크기:3089
2022-06-13 12:09:29 GMT+9
 저장 시간 : 2022-06-13 12:09:29 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<list>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	
	vector<list<string>> vls;



	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
		list<string>ls;

		for (auto p = i; p < j; ++p)
			ls.push_back(p->second);
		
		vls.push_back(ls);

		b = j;
	}	
	
	//vector<list<string>> 정렬
	// 개수순 
	sort(vls.begin(), vls.end(), [](const list<string>& a, const list<string>& b) {
		return a.size() > b.size();
		});
	cout << "가장 개수가 많은 쌍 - " << vls[0].size() << endl;
	//앞에서 부터 10개 출력

	for (const list<string>& ls : vls | views::take(10)) {
		for (const string& s : ls )
			cout << s << " ";
		cout << endl;
	}

}파일 정보 : 소스.cpp, 크기:3502
2022-06-13 12:11:45 GMT+9
 저장 시간 : 2022-06-13 12:11:45 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<list>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	
	vector<list<string>> vls;



	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
		list<string>ls;

		for (auto p = i; p < j; ++p)
			ls.push_back(p->second);
		
		vls.push_back(ls);

		b = j;
	}	
	
	//vector<list<string>> 정렬
	// 개수순 
	//sort(vls.begin(), vls.end(), [](const list<string>& a, const list<string>& b) {
	//	return a.size() > b.size();
	//	});
	//cout << "가장 개수가 많은 쌍 - " << vls[0].size() << endl;
	////앞에서 부터 10개 출력

	//for (const list<string>& ls : vls | views::take(10)) {
	//	for (const string& s : ls )
	//		cout << s << " ";
	//	cout << endl;
	//}
	//정렬 단어길이가 긴것 우선 
	sort(vls.begin(), vls.end(), [](const list<string>& a, const list<string>& b) {
		return a.begin()->size() > b.begin()->size();
		});
	cout << "가장 긴 단어는  - " << vls[0].begin()->size() << endl;
	//앞에서 부터 10개 출력

	for (const list<string>& ls : vls | views::take(10)) {
		for (const string& s : ls)
			cout << s << " ";
		cout << endl;
	}

}파일 정보 : 소스.cpp, 크기:3503
2022-06-13 12:12:45 GMT+9
 저장 시간 : 2022-06-13 12:12:45 GMT+9

//-----------------------------------------------------------------------------
//2022.6.8  수34                    월23수34                          (14주 2일)
//
//	anagram 찾기
//  
//   
// 6/15(수 15주 2일 ) - 기말시험 
// 6/20(월 15주 2일) - 끝
//-----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<string>
#include<vector>
#include<algorithm>
#include<ranges>
#include<list>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

struct WP : pair<string,string>{ //word pair
	WP(string s) : pair<string, string>{ s,s } {
		sort(first.begin(), first.end());
	}
};

int main()
{

	save("소스.cpp");

	ifstream in{ "단어들.txt",ios::binary };			
	vector<WP> v{ istream_iterator<string>{in},{} };
	cout << "읽은 단어 수 - " << v.size() << endl;

	ranges::sort(v, {}, &WP::first);

	// [문제] 입력한 단어가 사전에 있다면 
	// anagram 관계에 있는 단어를 모두 출력하라.

	//for (WP words : v | views::drop(15'0000)
	//	| views::take(100))
	//	cout << words.first << " --- " << words.second << endl;
	// 
	// 단어 정렬 

	//while (true) {
	//	string word;
	//	cout << " 찾을 단어는 ? ";
	//	cin >> word;
	//	// 입력한 단어가 사전에 있나?
	//	// 사전에 있는 단어라면
	//	//	단어를 정렬한다.
	//	//	정렬한 단어와 WP의 first와 일치하는 단어 쌍을 모두 찾는다.
	//	//  WP의 second를 출력한다. 
	//	WP wp(word);
	//	auto [상한, 하한] = equal_range(v.begin(), v.end(), wp, [](const WP& a, const WP& b) {return a.first < b.first; });
	//	
	//	if (하한 == 상한)
	//		cout << word << " 는 사전에 없는 단어 입니다. " << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << " 애너그램이 없는 단어 입니다. " << endl;
	//	else {
	//		cout << word << " -- ";
	//		for (auto i = 하한; i < 상한; ++i)
	//			cout << i->second << " ";
	//		cout << endl;
	//	}
	//}	
	for (WP words : v | views::drop(150000)
		| views::take(200))
		cout << words.first << " --- " << words.second << endl;
	 
	// [문제] 전체 anagram 쌍을 출력하라.
	// 현재 WP와 다음 WP에서 first 가 같니? - adjacent_find 
	// 같은 위치를 발견했다면 
	// 다음 달라지는 곳은 어디?
	auto b = v.cbegin();
	int cnt{};
	
	vector<list<string>> vls;



	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {return a.first == b.first; });
		if (i == v.cend())
			break;
		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {return a.first == i->first; });
		// {i , j ) 구간은 anagram 관계이다. 
		list<string>ls;

		for (auto p = i; p < j; ++p)
			ls.push_back(p->second);
		
		vls.push_back(ls);

		b = j;
	}	
	
	//vector<list<string>> 정렬
	// 개수순 
	//sort(vls.begin(), vls.end(), [](const list<string>& a, const list<string>& b) {
	//	return a.size() > b.size();
	//	});
	//cout << "가장 개수가 많은 쌍 - " << vls[0].size() << endl;
	////앞에서 부터 10개 출력

	//for (const list<string>& ls : vls | views::take(10)) {
	//	for (const string& s : ls )
	//		cout << s << " ";
	//	cout << endl;
	//}
	//정렬 단어길이가 긴것 우선 
	sort(vls.begin(), vls.end(), [](const list<string>& a, const list<string>& b) {
		return a.begin()->size() > b.begin()->size();
		});
	cout << "가장 긴 단어는  - " << vls[0].begin()->size() << endl;
	//앞에서 부터 10개 출력

	for (const list<string>& ls : vls | views::take(200)) {
		for (const string& s : ls)
			cout << s << " ";
		cout << endl;
	}

}